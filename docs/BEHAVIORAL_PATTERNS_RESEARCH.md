# Исследование №5: Поведенческие паттерны приложений

**CPU/IO-профили, реакция на nice/cgroups, noisy neighbor**

---

## 0. Цель исследования

Проанализировать поведенческие паттерны различных классов приложений, их реакцию на изменение приоритетов (nice, cgroups), и выявить подходы к решению проблемы "noisy neighbor" для применения в SmoothTask.

---

## 1. Что показывает практика по классам приложений

### 1.1. Браузеры (Chrome / Firefox / Chromium-подобные)

**Поведение:**

* При открытии вкладки / смене страницы — короткие, но очень жирные пики CPU (рендеринг, JS, layout, декодирование картинок/видео).
* В фоне вкладки *должны* быть относительно дешёвыми, но:
  * JS-таймеры и фоновые задачи (analytics, web apps) могут жрать до **40% всей работы фоновых вкладок**, поэтому Chrome ввёл агрессивное ограничение таймеров в фоне до 1 wake-up в минуту, что дало до **5× снижение CPU и +1.25 часа батареи**.
* Дополнительные источники CPU:
  * WebRTC / видеоконференции (blur background, эффекты) — могут держать вкладку на высоком CPU постоянно.

**I/O-паттерн:**

* Много мелких сетевых запросов + дисковый I/O под кэш и профили.
* При большом числе вкладок память — ключевой фактор: OOM / swapping → "лагает всё", даже если CPU не под 100%.

**Вывод для SmoothTask:**

* Сильная зависимость от **фокуса окна/вкладки**. Активная вкладка = кандидат на высокий приоритет, даже если *текущий* CPU небольшой.
* Фоновые вкладки с устойчивым CPU и без взаимодействия с пользователем = типичный noisy neighbor → можно снижать долю CPU/IO.
* Хороший proxy-признак: `browser + background + steady CPU > threshold + нет ввода` → сильный кандидат на даун-приоритизацию.

### 1.2. IDE / компиляция / дев-инструменты

**Поведение:**

* В режиме "редактирую код" IDE сама почти ничего не ест, основная нагрузка кратковременная (lint, indexer).
* При сборке (`cargo build`, `npm run build`, `make -jN`):
  * Многопроцессорная нагрузка: куча процессов компилятора.
  * Сильное CPU-использование + заметный disk I/O (чтение исходников, записи object-файлов, линковка).
  * Выигрыш от большего RAM (меньше пейджинга) зачастую более критичен, чем от ещё более быстрого CPU.

**I/O-паттерн:**

* Компиляция → смесь последовательного и случайного чтения/записи по большому числу файлов.
* При параллельной сборке возможно забивание I/O так, что интерфейс начинает "липнуть" из-за увеличения latency диска (классический эффект, который BFQ пытается лечить).

**Вывод для SmoothTask:**

* Очевидные паттерны:
  * `IDE_foreground + high CPU + клавиатура/мышь активны` → *интерактивный режим*, boost.
  * `компилятор / builder + долгий CPU / IO + IDE в фоне, но есть ввод` → компоновку и тесты лучше слегка придушить, чтобы редактор не лагал.
* Имеет смысл группировать **подпроцессы сборки** в один cgroup и управлять ими как "background batch".

### 1.3. Игры / 3D / мультимедиа / стриминг

**Поведение:**

* Игры и некоторые 3D-приложения по дизайну стремятся держать CPU/GPU максимально загруженными для FPS.
* Чувствительны к **tail latency** и к **шумным соседям** на том же ядре (гиперпоточность, AVX-тяжёлые задачи на соседнем hyper-thread ухудшают задержки).

**I/O-паттерн:**

* В основном чтение ресурсов при загрузке уровня + периодические записи логов / сетевой I/O в онлайн-играх.

**Вывод для SmoothTask:**

* Если окно игры в фокусе → почти всегда нужно давать ей максимум CPU и минимизировать помехи от других задач (интеграция с `taskset` / CPU pinning и ограничение тяжёлых фонов).
* Игровые лаунчеры / апдейтеры (Steam, Battle.net) в фоне — отдельная категория: при активной игре их нужно душить по CPU/IO.

### 1.4. Долгоживущие сервисы: БД, кеши, фоновые демоны

**Серверная картина, но применима и к десктопу / VM:**

* Работы по QoS для БД под нагрузкой показывают, что **даже при формально "справедливых" CPU-квотах cgroups** сосед-"деструктор" может сильно ухудшать tail latency БД, если не учесть особенности планировщика и I/O.
* Отдельное исследование по NVMe+cgroups показывает, что среди стандартных I/O-контроллеров Linux **io.cost** даёт наилучший уровень изоляции по I/O на NVMe (ценой небольшого оверхеда latency).

**Типичные сервисы:**

* БД / кэши (Postgres, Redis, локальные search-индексы).
* Desktop-демоны: индексаторы (tracker, baloo), cloud-синхронизация, backup-агенты.

**Вывод для SmoothTask:**

* Такие задачи полезно держать **в отдельном cgroup-слое** с мягкими/жёсткими лимитами CPU/IO; десктоп-интерактив всегда выше по важности.
* Для NVMe-систем на десктопе можно экспериментировать с io.cost / BFQ-based схемами для "background services".

---

## 2. Реакция разных классов на nice / cgroups

### 2.1. Уровень nice

* Современный CFS + **autogroup**: nice в значительной степени действует **только внутри одной "task group" (сессии)**. Если два процесса в разных терминалах / GUI-сессиях, изменение nice одного почти не влияет на другой.
* Автогруппировка включена по умолчанию на многих десктопных дистрибутивах (Ubuntu, Mint, Fedora, Manjaro).
* Практический итог: классические авто-найсеры типа ananicy оказываются частично слепы, если не умеют работать с `/proc/*/autogroup` или cgroups.

**Реакция по классам:**

* **Браузеры**: nice у отдельных процессов (renderer) помогает только если вся сессия в одном autogroup.
* **Компиляторы / бэкенды**: снижение nice заметно, если сборка идёт в отдельной группе, иначе эффект частично нивелируется.
* **Игры**: реально помогать будет не столько nice, сколько перевод шумных соседей в другие cgroups / снижение их группового nice.

### 2.2. Cgroups (CPU/IO/Memory)

* Cgroups позволяют задать **доли CPU (`cpu.shares`, `cpu.max`)**, лимиты памяти и I/O (weight, io.max/io.cost) для групп процессов; при этом неиспользованный CPU/I/O может забирать другая группа.
* В современных системах cgroups тесно интегрирован с systemd: сервисы и пользовательские сессии уже разнесены по дереву; это удобный якорь для SmoothTask.

**Реакция по классам:**

* **Игры / мультимедиа**: чувствительны к интерференции по CPU и L3-кэшу; их имеет смысл выделять в "premium" cgroup с полной долей CPU и, по возможности, отдельным набором ядер (через `taskset`/`cpuset`).
* **БД / индексаторы / backup**: хорошо живут в cgroup с ограниченным io.cost / io.max и CPU-долей; исследования по NVMe показывают, что правильно настроенный io.cost даёт наилучший компромисс между изоляцией и overhead.
* **Браузеры**: лучше всего не трогать весь браузер, а играться cgroups для heavy-подпроцессов (пример: отдельный cgroup для "фоновых вкладок" браузера — уже скорее интеграция через браузерные API).

---

## 3. Noisy neighbor и большие кластеры / VM

**На уровне серверов и облаков:**

* "Noisy neighbor" = когда одно приложение забирает ресурсы (CPU, cache, memory bandwidth, I/O) и ломает QoS соседям.

* Для Kubernetes/containers рекомендуют:
  * Комбинацию **cgroups** для CPU/memory/I/O +
  * аппаратные технологии типа Intel **RDT** (LLC cache и memory bandwidth partitioning) через `resctrl`, чтобы изолировать кэш и память от шумных соседей.

* Исследования по NVMe + cgroups показывают, что:
  * изолировать I/O сложно; простые веса не всегда дают предсказуемый tail latency;
  * `io.cost` даёт лучший баланс между изоляцией и пропускной способностью на NVMe.

**Релевантно для SmoothTask:**

* Идеи из мира кластеров переносятся в "микро-масштаб":
  * твой десктоп = маленький кластер; игра / IDE / активный браузер — это "Guaranteed QoS" workload;
  * индексаторы, апдейтеры, torrent-клиенты, фоновая аналитика — "BestEffort/Burstable".
* На уровне VM (VDS) важно, что:
  * внутри гостевой ОС SmoothTask видит только vCPU; но noisy neighbor может быть над тобой (другие VM). Это не починить, но можно минимизировать *свои* выбросы, чтобы самому не становиться noisy neighbor.

---

## 4. Паттерны по классам для SmoothTask

### 4.1. Browser Pattern

**Признаки:**

* `process_name in {chrome, chromium, firefox, brave,...}`
* есть связанное X11/Wayland окно → фокус / свернуто / на другом workspace;
* CPU>Х% и/или NET I/O постоянный.

**Эвристика:**

* если окно активно → high priority;
* если окно неактивно >N секунд, CPU стабильно выше порога → candidate for deprioritize (lower CPU share / более высокий nice группы).

**Политика:**

* Активная вкладка: `latency_nice = -15 to -10`, `nice = -4 to 0`
* Фоновые вкладки с high CPU: `latency_nice = +5 to +10`, `nice = +5 to +10`, ограничение `cpu.max` до 50%

### 4.2. IDE + Build Pattern

**Группа процессов:** IDE + дочерние компиляторы.

**Эвристика:**

* `IDE_foreground + high CPU + клавиатура/мышь активны` → *интерактивный режим*, boost.
* `компилятор / builder + долгий CPU / IO + IDE в фоне, но есть ввод` → компоновку и тесты лучше слегка придушить, чтобы редактор не лагал.

**Политика:**

* IDE в фокусе: `latency_nice = -10 to -5`, `nice = -4 to 0`, `cpu.weight = 200`
* Компиляторы (дочерние): отдельный cgroup с `cpu.weight = 50-100`, `cpu.max = 80%`, `io.cost` ограничение

### 4.3. Game / Full-screen GPU Pattern

**Признаки:**

* Fullscreen / borderless window + стабильный высокий FPS / GPU usage (через GPU counters, если доступны).
* Высокий постоянный CPU usage.

**Политика:**

* Во время игры:
  * Игра: `latency_nice = -20`, `nice = -7 to -5`, `cpu.weight = 300`, возможен CPU pinning
  * Все остальные приложения (кроме критичных VoIP): `latency_nice = +10 to +15`, ограничение `cpu.max`
  * Фоновые сервисы (обновлялки, индексаторы): агрессивное ограничение или пауза

### 4.4. Background Services / Daemons Pattern

**Признаки:**

* Systemd units + демоны без окон, с характерным длительным CPU/IO (backup, индексаторы, облако).
* Нет интерактивности, но могут быть критичными (VPN, аудио-сервер).

**Политика:**

* Индексаторы, обновлялки, торренты: `latency_nice = +15 to +19`, `nice = +10 to +19`, `cpu.weight = 25`, `io.cost` ограничение
* Критичные сервисы (VPN, аудио): `latency_nice = -5 to 0`, `nice = -2 to +2`, `cpu.weight = 100`

---

## 5. Использование nice vs cgroups в SmoothTask

### 5.1. Nice: ограниченное применение

**Использовать только:**

* внутри одной GUI-сессии (IDE vs её background задачи);
* для legacy-кейсов, где cgroups сложно применить;
* как дополнительный тонкий тюнинг внутри cgroup.

**Ограничения:**

* Для глобальной политики опираться на **autogroup + cgroups**, а не на голый nice.
* Nice работает только внутри autogroup, что ограничивает его эффективность.

### 5.2. Cgroups: основной инструмент

**Главная ось управления:**

* **Интерактивные приложения:**
  * высокие `cpu.shares` (150-300), без `cpu.max` (или очень высокий лимит);
  * `io.cost` с приоритетом интерактивности;
  * низкий `latency_nice` (-15 to -5).

* **Batch / Background:**
  * низкие `cpu.shares` (25-50);
  * опционально `cpu.max` (ограничение до 50-80%);
  * `io.cost` / `io.max` с ограничениями для I/O-heavy задач.

**Преимущества:**

* Изоляция между группами независимо от autogroup;
* Более предсказуемое поведение;
* Возможность точного контроля I/O через `io.cost`.

---

## 6. Заимствование идей из браузеров

### 6.1. Chrome Throttling Approach

Chrome-подход с throttling JS-таймеров показывает, что **знание "occlusion/focus state" даёт огромный выигрыш**.

**Для SmoothTask:**

* Отслеживание окон (активное / свернуто / на другом workspace / мониторе);
* Учёт этих признаков в ранкере: фоновые GUI-процессы без фокуса, но с высоким CPU — top candidates на урезание.

### 6.2. Применение

**Эвристика для фоновых процессов:**

```rust
if window_state == BACKGROUND && 
   cpu_steady > threshold && 
   time_since_user_input > timeout {
    candidate_for_deprioritize = true;
    target_cpu_weight = min(cpu_weight, 50);
    target_latency_nice = max(latency_nice, +10);
}
```

---

## 7. Структура QoS-классов для SmoothTask

### 7.1. Классы приоритетов

| Класс | Описание | cpu.weight | cpu.max | latency_nice | io.cost |
|-------|----------|------------|---------|--------------|---------|
| **LATENCY_CRITICAL** | Игры, RT-аудио | 300 | - | -20 to -15 | high priority |
| **INTERACTIVE** | Активный браузер, IDE | 150-200 | - | -15 to -10 | normal |
| **NORMAL** | Обычные процессы | 100 | - | -5 to +5 | normal |
| **BACKGROUND** | Фоновые GUI | 50-75 | 50-80% | +5 to +10 | limited |
| **BATCH** | Компиляторы, сборки | 50 | 80% | +10 to +15 | limited |
| **IDLE** | Индексаторы, обновлялки, торренты | 25 | 50% | +15 to +19 | idle/low |

### 7.2. Динамическое переключение классов

**Триггеры для изменения класса:**

1. **Фокус окна:** BACKGROUND → INTERACTIVE
2. **Время бездействия:** INTERACTIVE → BACKGROUND (если > 60 сек без ввода)
3. **Высокий CPU в фоне:** INTERACTIVE → BACKGROUND (если background > 30 сек и CPU > threshold)
4. **Запуск игры:** все остальные → снижение приоритета
5. **Начало сборки под IDE:** сборка → BATCH, IDE остаётся INTERACTIVE

---

## 8. Интеграция с autogroup

### 8.1. Учёт autogroup

**Важно:**

* Автогруппы включены по умолчанию на большинстве дистрибутивов;
* Nice работает только внутри autogroup;
* Cgroups работают независимо от autogroup.

**Стратегия SmoothTask:**

* Использовать cgroups как основной механизм (независим от autogroup);
* Nice использовать как дополнительный fine-tuning внутри группы;
* Мониторить `/proc/sys/kernel/sched_autogroup_enabled` и учитывать при логировании.

### 8.2. Группировка процессов

**AppGroup строится на основе:**

1. Родитель-потомок (ppid chain)
2. Cgroup membership (systemd unit)
3. Окна (одинаковый app_id)
4. Аудио-связи (PipeWire node → PID)

**Применение политик:**

* Политика применяется к всей группе (через cgroup);
* Отдельные процессы внутри группы могут иметь разные nice (fine-tuning).

---

## 9. Реализация в SmoothTask

### 9.1. Модуль Behavioral Patterns

```rust
pub struct AppBehavior {
    pub app_type: AppType,
    pub window_state: WindowState,
    pub cpu_pattern: CpuPattern,
    pub io_pattern: IoPattern,
    pub last_user_input: Option<Instant>,
    pub steady_cpu_threshold: f32,
}

pub enum CpuPattern {
    Idle,
    Bursty,      // короткие пики
    Steady,      // постоянная нагрузка
    Heavy,       // высокая постоянная нагрузка
}

pub enum IoPattern {
    Minimal,
    SmallRandom,  // мелкие случайные запросы
    Sequential,   // последовательный доступ
    HeavyRandom,  // тяжёлые случайные запросы
}
```

### 9.2. Интеграция с Policy Engine

```rust
impl PolicyEngine {
    fn evaluate_behavior(&self, process: &ProcessRecord, window: &WindowInfo) -> PriorityClass {
        let behavior = self.analyze_behavior(process, window);
        
        match (behavior.app_type, behavior.window_state) {
            (AppType::Browser, WindowState::Focused) => PriorityClass::INTERACTIVE,
            (AppType::Browser, WindowState::Background) if behavior.cpu_pattern == CpuPattern::Steady => {
                PriorityClass::BACKGROUND  // noisy neighbor
            },
            (AppType::IDE, WindowState::Focused) => PriorityClass::INTERACTIVE,
            (AppType::Game, WindowState::Fullscreen) => PriorityClass::LATENCY_CRITICAL,
            // ...
        }
    }
}
```

---

## 10. Выводы

Исследования вокруг браузеров, компиляторов, БД и кластерных noisy-neighbor-кейсов сходятся к одному:

* Сам по себе **nice уже недостаточен** для точного контроля — из-за autogroup и группового планирования.
* Реально работает связка:
  * **классификация по типу приложения + состоянию окна**,
  * **cgroups (CPU/IO/Memory) как основной рычаг**,
  * при необходимости — pinning на ядра и, в серверном мире, cache/memory-bandwidth-изоляция (Intel RDT).

**Для SmoothTask это означает:**

* Ранкер по-прежнему остаётся "верхним уровнем", но под ним появляются **жёсткие классы QoS**, привязанные к реальным поведенческим паттернам приложений (браузер, IDE+build, игра, сервисы, VoIP и т. д.), которые дальше мапятся на cgroups-профили и, при необходимости, на nice внутри группы.
* Знание состояния окна (фокус/фон) — критически важно для принятия решений.
* Фоновые процессы с steady high CPU — типичные noisy neighbors, кандидаты на агрессивное ограничение.

---

## Источники

- [Intel: Resolving Noisy Neighbors Problem in Kubernetes](https://www.intel.com/content/www/us/en/developer/articles/technical/noisy-neighbors-problem-in-kubernetes.html)
- [Middleware.io: Ways to Prevent CPU Overload on Linux Servers](https://middleware.io/blog/prevent-cpu-overload-on-linux-servers/)
- [Medium: Linux Beyond the Basics - Cgroups](https://medium.com/%40weidagang/linux-beyond-the-basics-cgroups-f157d93bd755)
- [Reddit: Why nice levels are a placebo](https://www.reddit.com/r/linux/comments/d7hx2c/why_nice_levels_are_a_placebo_and_have_been_for_a/)







