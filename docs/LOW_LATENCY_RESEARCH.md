# Исследование №3: Низко-латентные гайды и best practices

**Анализ практик настройки низкой латентности в Linux и их применимость к SmoothTask**

---

## 0. Цель исследования

Проанализировать существующие гайды и практики по достижению низкой латентности в Linux, выделить ключевые механизмы и рекомендации, которые можно интегрировать в дизайн SmoothTask.

### Фокус исследования:

1. Как **люди добиваются низкой латентности**:
   * реальное использование PipeWire/JACK;
   * системный тюнинг (cpu governor, swappiness, I/O-scheduler, cgroups).
2. Какие **процессы и классы задач** эти гайды предлагают:
   * поднимать по приоритету (аудио, игры, интерактивный UI);
   * душить (индексация, бэкапы, обновлялки, торренты, фоновый билд).
3. Какие **механизмы ядра** для латентности сейчас считаются "правильными":
   * `latency_nice`, CFS-тюнинг, autogroup, BFQ и т.п.

---

## 1. Низко-латентный звук (PipeWire / JACK / RT-аудио)

### 1.1. Общие выводы из Linux Audio wiki + rtcqs

Linuxaudio.org даёт довольно свежий, аккуратный обзор: хороший RT-аудио сетап складывается из **набора мелких шагов**, а не одной «магической» настройки. Современное ядро часто **не требует** RT-патча, хотя RT-ядро может ещё улучшить ситуацию в экстремальных кейсах.

Ключевые паттерны, которые повторяются:

* Использование скрипта **`rtcqs`**:
  * проверка `rtprio`/`memlock` лимитов для аудио-группы;
  * проверка губернатора CPU (часто рекомендуют `performance`);
  * проверка swappiness, irq, tickless/hi-res timers.
* Системные параметры, которые почти всегда фигурируют:
  * **CPU governor**: `performance` для аудио/лайва, чтобы избежать задержек из-за частотного скалинга;
  * **vm.swappiness** около 10 или ниже (иногда 1), чтобы система **позже лезла в swap** и не выпадала в дикое замедление по диску;
  * Tickless-ядро, high-res timers, IRQ без диких конфликтов.

**Вывод для SmoothTask:**

Это не то, чем должен заниматься демон каждую секунду, но:

* он может **читать** часть этих параметров и:
  * логировать «несоответствие best practice»;
  * включать/выключать более агрессивные политики, понимая, что, например, swappiness=60 → под swap'ом будет больно, и лучше заранее душить фон.

### 1.2. PipeWire: как в гайдах тюнят латентность

На примере обсуждений EndeavourOS/Manjaro: типичный рецепт низкой задержки PipeWire такой:

* работа идёт в `~/.config/pipewire/pipewire.conf`;
* критичные параметры:

```ini
default.clock.rate = 48000       # sample rate
default.clock.quantum = 1024     # размер буфера в сэмплах
default.clock.min-quantum = 16   # минимальный quantum
default.clock.max-quantum = 2048 # максимум
default.clock.quantum-limit = 8192
```

* формула реальной латентности:
  * latency ≈ `(quantum / rate) * 1000` мс, плюс небольшой overhead PipeWire;
  * пример: `(1024 / 48000) * 1000 ≈ 21.3ms` → округляют до ~22ms.
* `min-quantum` / `max-quantum`:
  * если задать одинаковыми → фиксированная латентность;
  * если разными → PipeWire может **динамически увеличивать latency**, чтобы перебороть xruns.

**Вывод для SmoothTask:**

* SmoothTask **не обязан** ковырять pipewire.conf, но:
  * он может знать «целевой класс»: если процесс помечен как `audio_rt`, мы не имеем права его душить по CPU/IO, пока не начался «критический ад»;
  * можно логировать события типа: `audio_client + xruns + high PSI` → триггер для более жёсткого душения фона.

### 1.3. RT-потоки, rtkit и "Audio group"

Автоматический тюнинг аудио описывает скрипт, который:

* поднимает приоритет **audio-группы**;
* меняет **политику планирования потоков** на `SCHED_FIFO` (реальное время) для аудио;
* тем самым улучшает задержку и стабильность аудио.

Современные дистрибутивы чаще полагаются на **`rtkit`** + права `realtime`-группы, но паттерн тот же:

* существует **особый класс задач "Audio/RT"**, у которых:
  * жёстко подняты scheduler-приоритеты;
  * увеличен memlock/rtprio;
  * фоновые сервиса должны им **уступить дорогу**.

**Вывод для SmoothTask:**

* нам нужен **отдельный класс `AUDIO_RT`** в policy:
  * `latency_nice` → максимально низкое значение (латентность критична);
  * `nice` — умеренно отрицательный;
  * IO — не душим вообще (кроме экстремальных ситуаций);
* SmoothTask должен **ни разу не перебивать** выбор rtkit, но может:
  * следить, чтобы аудио-процессы не оказывались в «фоновых cgroup», куда он сам складывает билд/backup/торренты.

---

## 2. Гайды по desktop/gaming-латентности

### 2.1. CFS + autogroup + sysctl

В обсуждениях оптимизации responsiveness на десктопе (ArchLinux, Unix.SE, etc.) общий тезис: **стоковый CFS-планировщик достаточно хорош**, если:

* включен (или настроен) **autogroup** (`/proc/sys/kernel/sched_autogroup_enabled = 1`):
  * GUI-сессия и каждый терминал попадают в отдельный scheduling-group;
  * это сильно улучшает отзывчивость при большом количестве задач;
* подправлены несколько `vm.*` sysctl:
  * `vm.swappiness=1` или 10;
  * `vm.dirty_background_bytes` и `vm.dirty_bytes` уменьшаются, чтобы **не копить гигантские грязные страницы** и не блокировать I/O одним большим сбросом;
* подобран адекватный I/O-scheduler:
  * для десктопа часто рекомендуют **BFQ** или аналоги, как более дружелюбные к интерактивным приложениям;

**При этом подмечается важный момент:**

При включённом autogroup обычный `nice`/`renice` влияет **только внутри группы**, то есть `nice +15 make -j` в терминале не мешает терминалу как группе получить жирный кусок CPU.

→ Для точного управления приоритетом надо либо:

* управлять **autogroup** (`/proc/<pid>/autogroup`),
* либо использовать **cgroups**.

Это прямое подтверждение, что у SmoothTask должен быть **уровень "group-policy"**, а не только per-pid.

### 2.2. latency_nice: новый стандартный инструмент

LWN подробно разбирает `latency_nice` — это **вторая "ниса"**, которая влияет на *когда* процесс получает CPU, а не на *сколько* CPU он получит.

**Ключевые моменты:**

* диапазон: **[-20 … 19]**, по смыслу похож на nice:
  * `-20` — максимально чувствителен к задержке (UI, аудио, игры);
  * `19` — «мне всё равно, подожду» (batch, cron, индексация);
  * по умолчанию `0`.
* управление:
  * через `sched_setattr()` (поле `latency_nice` + флаг `SCHED_FLAG_LATENCY_NICE`);
  * либо через cgroup-контроллер `latency`.
* влияние:
  * процесс с **более высоким приоритетом по latency_nice** может *прервать* текущий, когда просыпается;
  * CPU-квота не меняется, но **момент получения CPU** смещается ближе к моменту wakeup.

→ Это почти готовый идеальный инструмент для SmoothTask:

* типы `AUDIO_RT`, `UI_INTERACTIVE`, `GAME` → `latency_nice ≈ -15 … -20`;
* `BG_CPUIO`, `indexer`, `backup`, `package-updates` → `latency_nice ≈ +10 … +19`;
* ML-ранкер может внутри этих диапазонов чуть подвинуть значение (тонкая настройка).

### 2.3. Gaming-тюнинг и фоновые задачи

По гайдам «оптимизация десктопа / игр»:

* игры / тяжёлые интерактивные приложения:
  * держать CPU-governor в `performance` во время сессии;
  * не запускать в этот момент тяжёлые пакман/apt-обновления, бэкапы, reindex и т.д.;
  * часто советуют Ananicy/ananicy-cpp, где **`Game` и `Player-*` поднимаются**, а `BG_CPUIO` жестко опускается по nice/ionice.
* фоновые сервисы:
  * индексаторы (Baloo/Tracker/Recoll), backup (Timeshift, rsync-скрипты), обновлялки (apt, pacman, snapd, flatpak), torrent-демоны:
    * им явно рекомендуют **увеличивать nice и снижать IO-приоритет**, чтобы не ломали интерфейс и аудио.

Для SmoothTask это прямо готовые классы:

* **поднять**:
  * браузерные вкладки с активным аудио/видео;
  * активное окно игры (`game`, `wine/proton`, `steam`-дети);
  * активный терминал/IDE с пользовательским вводом.
* **опустить**:
  * любая индексация (`baloo*`, `tracker*`, `recollindex`);
  * пакетные менеджеры и их сервисы (`apt*`, `dnf*`, `pacman`, `snapd`, `flatpak-system-helper`, `packagekitd`);
  * бэкапы (`timeshift`, `rsync`, `borg`, `restic` и т.п.);
  * торренты (`qbittorrent`, `transmission-*`, `deluge`, `rtorrent`).

---

## 3. Best practices по background-сервисам

Из аудио- и общих performance-гайдов вылезает одинаковая мысль: **фон должен быть "вежливым" всегда**, а в моменты активной работы (игры/аудио/стрим) — особенно.

Типичные рекомендации:

1. **Обновления**:
   * переносить на простои, не запускать heavy обновления по cron в прайм-тайм;
   * для десктопа ок, если `apt-daily`, `dnf-makecache` и т.п. будут работать реже и на низком приоритете.
2. **Индексация и десктоп-поиск**:
   * либо отключать, либо ограничивать по CPU/IO, особенно на HDD;
   * Baloo/Tracker обычно не критичны "здесь и сейчас".
3. **Бэкапы и snapshot'ы**:
   * Timeshift и подобные на практике сильно роняют responsiveness, если не ограничены по IO; гайды прямо предлагают ставить им `nice` и `ionice=idle`.
4. **Торренты**:
   * на десктопе нормально, если torrent-клиент всегда в `background` классе, а в игровые/аудио-сессии ещё и ограничен по скорости или IO.

Всё это можно превратить в **жёсткие policy-ограничения** в SmoothTask:

* классы `INDEXER`, `BACKUP`, `UPDATER`, `TORRENT_DAEMON`:
  * `latency_nice` → высокое (например, +15…+19);
  * `nice` ≥ +10;
  * IO — либо `idle`, либо максимум low `best-effort`;
  * при детекте плохой отзывчивости — первые кандидаты на "задушить".

---

## 4. Системные параметры и их мониторинг

### 4.1. CPU Governor

**Рекомендации:**
* `performance` — для игр, аудио, низкой латентности;
* `ondemand` / `schedutil` — для общего использования;
* `powersave` — избегать на десктопе, если важна отзывчивость.

**Для SmoothTask:**
* Мониторинг текущего governor (читаем `/sys/devices/system/cpu/cpu*/cpufreq/scaling_governor`);
* Логирование предупреждений, если governor неоптимален для активных интерактивных задач;
* Возможность рекомендовать изменение (но не менять автоматически без явного разрешения).

### 4.2. Swappiness

**Рекомендации:**
* `vm.swappiness = 1` или `10` для десктопа;
* `vm.swappiness = 60` (дефолт) может вызывать проблемы при нехватке памяти.

**Для SmoothTask:**
* Чтение текущего значения (`/proc/sys/vm/swappiness`);
* Учёт swappiness при принятии решений:
  * высокая swappiness → более агрессивное душение фона при нехватке памяти;
  * низкая swappiness → система менее склонна к swap, но может OOM.

### 4.3. I/O Scheduler

**Рекомендации:**
* **BFQ** — предпочтителен для десктопа (лучше для интерактивных задач);
* **mq-deadline** — альтернатива для NVMe;
* **none** / **noop** — для некоторых SSD.

**Для SmoothTask:**
* Мониторинг текущего I/O scheduler;
* Учёт scheduler при принятии решений по IO-приоритетам.

### 4.4. Autogroup

**Важно:**
* Автогруппы влияют на то, как работает `nice` внутри групп;
* Для точного управления нужен контроль над группами или cgroups.

**Для SmoothTask:**
* Учёт autogroup при применении приоритетов;
* Предпочтение cgroups для более точного контроля.

---

## 5. Таблица классов → диапазоны приоритетов

На основе анализа гайдов и best practices:

| Класс | nice | latency_nice | ionice class | ionice level | Описание |
|-------|------|--------------|--------------|--------------|----------|
| **AUDIO_RT** | -4 to -2 | -20 to -15 | best-effort | 0-2 | RT-аудио, DAW, JACK/PipeWire клиенты |
| **GAME** | -7 to -5 | -20 to -15 | best-effort | 0-3 | Игры, игровые лаунчеры |
| **UI_INTERACTIVE** | -4 to 0 | -15 to -10 | best-effort | 2-4 | Активный браузер, IDE, терминал с вводом |
| **PLAYER_AUDIO** | -4 to -2 | -15 to -10 | best-effort | 1-3 | Аудиоплееры |
| **PLAYER_VIDEO** | -4 to -2 | -15 to -10 | best-effort | 1-3 | Видеоплееры |
| **NORMAL** | 0 | -5 to 5 | best-effort | 4-5 | Обычные процессы по умолчанию |
| **SERVICE** | -2 to 2 | -2 to 2 | best-effort | 4-6 | Системные сервисы |
| **DAEMON** | 0 to 5 | 0 to 5 | best-effort | 4-6 | Фоновые демоны |
| **BG_CPU** | 5 to 15 | 10 to 17 | best-effort | 5-7 | Фоновые CPU-задачи |
| **INDEXER** | 10 to 19 | 15 to 19 | idle / best-effort | 6-7 | Индексаторы (Baloo, Tracker, Recoll) |
| **UPDATER** | 10 to 19 | 15 to 19 | idle / best-effort | 6-7 | Пакетные менеджеры, обновлялки |
| **BACKUP** | 10 to 19 | 15 to 19 | idle | 6-7 | Бэкапы, snapshot'ы |
| **TORRENT** | 10 to 19 | 15 to 19 | idle / best-effort | 6-7 | Торрент-клиенты, демоны |

---

## 6. Что из этого прямо идёт в дизайн SmoothTask

### 6.1. Использовать `latency_nice` как основной рычаг lat-policy

На основе гайдов и работы ядра:

* вводим карты:
  * `AUDIO_RT` / `UI_INTERACTIVE` / `GAME` → `latency_nice` в районе `-20 … -10`;
  * `NORMAL` → около `0`;
  * `BACKGROUND_HEAVY` (`BG_CPUIO`, indexer, backup, updates, torrent) → `+10 … +19`.
* обычный `nice` используем для CPU-шеринга, но не как главный инструмент латентности.

### 6.2. Работать на уровне групп, а не только процессов

* высокий приоритет GUI/терминала/игры/DAW должен отражаться на **всём их дереве процессов**;
* с учётом autogroup и cgroups приоритеты должны выставляться так, чтобы:
  * `nice/latency_nice` процессов+групп давали консистентный результат;
  * "`nice`-placebo" эффекта (как при автогруппинке) избежать за счёт управления группами.

### 6.3. Знать о системных настройках, но не ломать их вслепую

* SmoothTask может:
  * считывать swappiness, governor, I/O-scheduler;
  * хранить в логах/метриках флаг "система далеко от best practice";
  * опционально иметь режим "агрессивный desktop-tuning", где он сам подкручивает часть параметров (но это отдельный, явно включаемый модуль).

### 6.4. Жёстко фиксированные классы для фона (best practice из гайдов)

Минимальный набор:

* `AUDIO_RT`: DAW, JACK/PipeWire-клиенты, системные аудио-демоны;
* `GAME`: игры, Proton/Wine-дети;
* `UI_INTERACTIVE`: активный браузер, IDE, терминал с вводом;
* `BACKGROUND_HEAVY`:
  * индексаторы (`baloo*`, `tracker*`, `recollindex`);
  * обновлялки (`apt*`, `dnf*`, `pacman`, `snapd`, `flatpak-system-helper`, `packagekitd`);
  * бэкапы (`timeshift`, rsync-скрипты, borg/restic);
  * torrent-клиенты/демоны.

Для этих классов мы можем сразу зашить «жёсткую» политику nice/ionice/latency_nice на основе того, как это уже делают Ananicy/аудио-скрипты/гайды.

### 6.5. Интеграция с аудио-стеком без вмешательства в его внутренности

* SmoothTask **не трогает PipeWire/JACK-конфиг** напрямую;
* но:
  * знает, что аудио-клиенты → `AUDIO_RT`;
  * следит, чтобы их не вытесняли фоновые задачи;
  * может использовать PSI + свои метрики "bad_responsiveness" и (в будущем) счётчик xruns как триггер для того, чтобы ещё сильнее опустить фон.

---

## 7. Рекомендации по реализации

### 7.1. Модуль мониторинга системных параметров

```rust
pub struct SystemParams {
    pub cpu_governor: String,
    pub swappiness: u32,
    pub io_scheduler: String,
    pub autogroup_enabled: bool,
    // ...
}

impl SystemParams {
    pub fn read() -> Result<Self> { /* ... */ }
    pub fn is_optimal_for_low_latency(&self) -> bool { /* ... */ }
}
```

### 7.2. Расширение Policy Engine

* Добавить классы `AUDIO_RT`, `BACKGROUND_HEAVY` с жёсткими правилами;
* Использовать `latency_nice` как основной инструмент управления латентностью;
* Интегрировать проверку системных параметров в процесс принятия решений.

### 7.3. AppGroup с учётом autogroup

* При построении AppGroup учитывать autogroup членство;
* Применять приоритеты на уровне cgroups, а не только per-pid;
* Гарантировать консистентность приоритетов внутри группы.

---

## 8. Следующие шаги

1. Реализовать чтение и мониторинг системных параметров (governor, swappiness, I/O scheduler);
2. Расширить типы приложений в `types.yaml` классами `AUDIO_RT` и `BACKGROUND_HEAVY`;
3. Интегрировать `latency_nice` в Actuator как основной инструмент управления латентностью;
4. Реализовать групповую политику с учётом autogroup и cgroups;
5. Добавить детекцию "bad_responsiveness" с триггерами для более агрессивного душения фона.

---

## Источники

- [Automated Tuning Of Linux Audio - Hackaday](https://hackaday.com/2019/04/10/automated-tuning-of-linux-audio/)
- [Linux Audio Wiki](https://wiki.linuxaudio.org/)
- [LWN: latency_nice](https://lwn.net/Articles/932362/)
- [Arch Linux Performance Tuning](https://wiki.archlinux.org/title/Improving_performance)
- Обсуждения на форумах EndeavourOS, Manjaro, r/linuxaudio

