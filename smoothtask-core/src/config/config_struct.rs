use anyhow::{ensure, Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

use crate::metrics::ebpf::EbpfConfig;

/// Конфигурация ML-классификатора для классификации типов процессов.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct MLClassifierConfig {
    /// Включить ML-классификатор.
    ///
    /// Если `true`, будет использоваться ML-классификатор для классификации процессов
    /// в дополнение к паттерн-базированной классификации.
    ///
    /// По умолчанию: `false` (используется только паттерн-базированная классификация).
    #[serde(default = "default_ml_classifier_enabled")]
    pub enabled: bool,

    /// Путь к модели ML-классификатора.
    ///
    /// Путь к файлу модели в формате JSON или ONNX.
    /// Модель должна быть предварительно обучена с использованием smoothtask-trainer.
    ///
    /// По умолчанию: `"models/process_classifier.json"`.
    #[serde(default = "default_ml_classifier_model_path")]
    pub model_path: String,

    /// Минимальная уверенность для переопределения паттерн-классификации.
    ///
    /// Если уверенность ML-классификатора выше этого порога,
    /// результат ML будет использоваться вместо паттерн-классификации.
    ///
    /// По умолчанию: `0.7` (70% уверенность).
    ///
    /// # Примечания
    ///
    /// - Значение должно быть в диапазоне [0.0, 1.0]
    /// - Рекомендуемые значения: 0.6 (более агрессивное переопределение), 0.7 (баланс),
    ///   0.8 (более консервативное переопределение)
    #[serde(default = "default_ml_classifier_confidence_threshold")]
    pub confidence_threshold: f64,

    /// Тип ML-модели для классификации.
    ///
    /// Определяет формат модели: CatBoost JSON или ONNX.
    /// Это влияет на то, какой бэкенд будет использоваться для загрузки и выполнения модели.
    ///
    /// По умолчанию: `ModelType::Catboost` (CatBoost JSON формат).
    ///
    /// # Примечания
    ///
    /// - CatBoost JSON формат удобен для отладки и тестирования
    /// - ONNX формат оптимизирован для production и имеет лучшую производительность
    /// - Тип модели должен соответствовать фактическому формату файла модели
    #[serde(default = "default_ml_classifier_model_type")]
    pub model_type: ModelType,
}

/// Возвращает дефолтное значение для `ml_classifier_enabled`.
pub(crate) fn default_ml_classifier_enabled() -> bool {
    false
}

/// Возвращает дефолтное значение для `ml_classifier_model_path`.
pub(crate) fn default_ml_classifier_model_path() -> String {
    "models/process_classifier.json".to_string()
}

/// Возвращает дефолтное значение для `ml_classifier_confidence_threshold`.
pub(crate) fn default_ml_classifier_confidence_threshold() -> f64 {
    0.7
}

/// Возвращает дефолтное значение для `ml_classifier_model_type`.
///
/// По умолчанию используется `ModelType::Catboost` как более портативный
/// и простой в отладке формат.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_ml_classifier_model_type")]`
/// - CatBoost JSON формат рекомендуется для отладки и тестирования
/// - ONNX формат может быть использован для production
pub(crate) fn default_ml_classifier_model_type() -> ModelType {
    ModelType::Catboost
}

/// Конфигурация логирования для системы.
///
/// Определяет параметры ротации логов, сжатия и другие настройки логирования.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct LoggingConfig {
    /// Максимальный размер файла лога в байтах перед ротацией.
    ///
    /// Если файл лога достигает или превышает этот размер, происходит ротация.
    /// Значение 0 означает отключение ротации по размеру.
    ///
    /// По умолчанию: 10_485_760 байт (10 MiB).
    ///
    /// # Примечания
    ///
    /// - Значение должно быть >= 0
    /// - Значение должно быть <= 1_073_741_824 (1 GiB) для предотвращения чрезмерного использования диска
    /// - Рекомендуемые значения: 1 MiB (1_048_576), 5 MiB (5_242_880), 10 MiB (10_485_760)
    #[serde(default = "default_log_max_size_bytes")]
    pub log_max_size_bytes: u64,

    /// Максимальное количество сохраняемых ротированных логов.
    ///
    /// Определяет, сколько ротированных логов будет сохранено перед удалением самых старых.
    /// Значение 0 означает отключение ограничения (все ротированные логи сохраняются).
    ///
    /// По умолчанию: 5.
    ///
    /// # Примечания
    ///
    /// - Значение должно быть >= 0
    /// - Значение должно быть <= 100 для предотвращения чрезмерного использования диска
    /// - Рекомендуемые значения: 3, 5, 10
    #[serde(default = "default_log_max_rotated_files")]
    pub log_max_rotated_files: u32,

    /// Включить сжатие ротированных логов.
    ///
    /// Если `true`, ротированные логи будут сжаты с использованием gzip.
    /// Это позволяет сэкономить дисковое пространство, но требует дополнительных ресурсов CPU.
    ///
    /// По умолчанию: `true`.
    ///
    /// # Примечания
    ///
    /// - Сжатие применяется только к ротированным логам, а не к текущему активному логу
    /// - Сжатые логи имеют расширение .gz
    /// - Требует наличия библиотеки сжатия (flate2)
    #[serde(default = "default_log_compression_enabled")]
    pub log_compression_enabled: bool,

    /// Интервал ротации логов по времени в секундах.
    ///
    /// Если указано значение > 0, логи будут ротироваться через указанные интервалы времени,
    /// независимо от размера файла. Это полезно для создания регулярных снапшотов логов.
    ///
    /// Значение 0 означает отключение ротации по времени.
    ///
    /// По умолчанию: 0 (отключено).
    ///
    /// # Примечания
    ///
    /// - Значение должно быть >= 0
    /// - Значение должно быть <= 86400 (24 часа) для предотвращения чрезмерных интервалов
    /// - Рекомендуемые значения: 3600 (1 час), 10800 (3 часа), 21600 (6 часов), 43200 (12 часов)
    /// - Если указано как ротация по размеру, так и по времени, будет использоваться то условие,
    ///   которое наступит первым
    #[serde(default = "default_log_rotation_interval_sec")]
    pub log_rotation_interval_sec: u64,
}

/// Возвращает дефолтное значение для `log_max_size_bytes`.
///
/// По умолчанию используется значение 10_485_760 байт (10 MiB).
/// Это разумный компромисс между частотой ротации и использованием дискового пространства.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_log_max_size_bytes")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_log_max_size_bytes() -> u64 {
    10_485_760 // 10 MiB
}

/// Возвращает дефолтное значение для `log_max_rotated_files`.
///
/// По умолчанию используется значение 5. Это позволяет сохранить несколько ротированных логов
/// для отладки, не занимая слишком много дискового пространства.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_log_max_rotated_files")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_log_max_rotated_files() -> u32 {
    5
}

/// Возвращает дефолтное значение для `log_compression_enabled`.
///
/// По умолчанию сжатие включено (`true`), так как это позволяет значительно сэкономить
/// дисковое пространство при минимальном влиянии на производительность.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_log_compression_enabled")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_log_compression_enabled() -> bool {
    true
}

/// Возвращает дефолтное значение для `log_rotation_interval_sec`.
///
/// По умолчанию ротация по времени отключена (0 секунд).
/// Это позволяет использовать только ротацию по размеру или отключить ротацию полностью.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_log_rotation_interval_sec")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_log_rotation_interval_sec() -> u64 {
    0
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Config {
    pub polling_interval_ms: u64,
    pub max_candidates: usize,
    pub dry_run_default: bool,
    #[serde(default = "default_policy_mode")]
    pub policy_mode: PolicyMode,
    /// Флаг включения логирования снапшотов в SQLite.
    ///
    /// Если `true`, снапшоты будут записываться в БД, указанную в `paths.snapshot_db_path`.
    /// Если `false`, логирование снапшотов будет отключено, даже если путь указан.
    ///
    /// По умолчанию: `false` (логирование отключено).
    #[serde(default = "default_enable_snapshot_logging")]
    pub enable_snapshot_logging: bool,

    pub thresholds: Thresholds,
    pub paths: Paths,
    /// Конфигурация логирования для системы.
    ///
    /// Определяет параметры ротации логов, сжатия и другие настройки логирования.
    /// Эти параметры применяются как к текстовым логам (tracing), так и к логам снапшотов.
    ///
    /// По умолчанию: используется дефолтная конфигурация с ротацией по размеру (10 MiB),
    /// сохранением 5 ротированных файлов, включенным сжатием и отключенной ротацией по времени.
    #[serde(default = "default_logging_config")]
    pub logging: LoggingConfig,
    /// Интервалы кэширования для оптимизации производительности.
    ///
    /// Определяет, как часто обновляются кэши системных и процессных метрик.
    /// Кэширование позволяет снизить нагрузку на систему за счёт повторного использования
    /// ранее собранных данных в течение нескольких итераций.
    ///
    /// По умолчанию: обновление каждые 3 итерации для системных метрик,
    /// обновление каждую итерацию для метрик процессов (отключено).
    #[serde(default = "default_cache_intervals")]
    pub cache_intervals: CacheIntervals,

    /// Конфигурация системы уведомлений.
    ///
    /// Определяет параметры отправки уведомлений пользователю о важных событиях
    /// в работе демона. Поддерживает различные бэкенды (заглушки, desktop уведомления и т.д.).
    ///
    /// По умолчанию: уведомления отключены, используется заглушка для тестирования.
    #[serde(default = "default_notification_config")]
    pub notifications: NotificationConfig,
    /// Конфигурация ML-модели для ранжирования.
    ///
    /// Определяет параметры загрузки и использования ML-модели для ранжирования AppGroup.
    /// Используется только в hybrid режиме Policy Engine.
    ///
    /// По умолчанию: модель отключена, используется заглушка для тестирования.
    #[serde(default = "default_model_config")]
    pub model: ModelConfig,

    /// Конфигурация ML-классификатора для классификации типов процессов.
    ///
    /// Определяет параметры загрузки и использования ML-классификатора для определения
    /// типов процессов (process_type) и тегов. Работает в дополнение к паттерн-базированной
    /// классификации и может переопределять её результаты при высокой уверенности.
    ///
    /// По умолчанию: ML-классификатор отключен, используется только паттерн-базированная классификация.
    #[serde(default = "default_ml_classifier_config")]
    pub ml_classifier: MLClassifierConfig,

    /// Конфигурация автообновления паттерн-базы для классификации процессов.
    ///
    /// Определяет параметры автоматического обновления паттернов приложений без перезапуска демона.
    /// Позволяет добавлять поддержку новых приложений и обновлять существующие паттерны на лету.
    ///
    /// По умолчанию: автообновление отключено, паттерны загружаются один раз при старте.
    #[serde(default = "default_pattern_auto_update_config")]
    pub pattern_auto_update: PatternAutoUpdateConfig,

    /// Конфигурация eBPF для сбора метрик.
    ///
    /// Определяет параметры использования eBPF для сбора системных метрик.
    /// eBPF позволяет получать более точные и детализированные данные о системе
    /// с меньшими накладными расходами.
    ///
    /// По умолчанию: eBPF отключен, используются стандартные методы сбора метрик.
    #[serde(default = "default_ebpf_config")]
    pub ebpf: EbpfConfig,
}

/// Возвращает дефолтное значение для `ml_classifier`.
///
/// По умолчанию ML-классификатор отключен, используется только паттерн-базированная классификация.
pub(crate) fn default_ml_classifier_config() -> MLClassifierConfig {
    MLClassifierConfig {
        enabled: default_ml_classifier_enabled(),
        model_path: default_ml_classifier_model_path(),
        confidence_threshold: default_ml_classifier_confidence_threshold(),
        model_type: default_ml_classifier_model_type(),
    }
}

/// Конфигурация автообновления паттерн-базы.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct PatternAutoUpdateConfig {
    /// Включить автообновление паттерн-базы.
    ///
    /// Если `true`, демон будет отслеживать изменения в директории с паттернами
    /// и автоматически перезагружать паттерны при обнаружении изменений.
    ///
    /// По умолчанию: `false` (автообновление отключено).
    #[serde(default = "default_pattern_auto_update_enabled")]
    pub enabled: bool,

    /// Интервал проверки изменений в секундах.
    ///
    /// Определяет, как часто демон будет проверять изменения в директории с паттернами.
    /// Более частые проверки обеспечивают более быстрое обновление, но увеличивают нагрузку.
    ///
    /// По умолчанию: `60` секунд (1 минута).
    ///
    /// # Примечания
    ///
    /// - Значение должно быть >= 10 секунд для предотвращения чрезмерной нагрузки
    /// - Рекомендуемые значения: 30 (30 секунд), 60 (1 минута), 300 (5 минут)
    #[serde(default = "default_pattern_auto_update_interval_sec")]
    pub interval_sec: u64,

    /// Включить уведомления об обновлении паттернов.
    ///
    /// Если `true`, демон будет отправлять уведомления через систему уведомлений
    /// при успешном обновлении паттерн-базы.
    ///
    /// По умолчанию: `false` (уведомления отключены).
    #[serde(default = "default_pattern_auto_update_notify")]
    pub notify_on_update: bool,
}

/// Возвращает дефолтное значение для `pattern_auto_update_enabled`.
pub(crate) fn default_pattern_auto_update_enabled() -> bool {
    false
}

/// Возвращает дефолтное значение для `pattern_auto_update_interval_sec`.
pub(crate) fn default_pattern_auto_update_interval_sec() -> u64 {
    60
}

/// Возвращает дефолтное значение для `pattern_auto_update_notify`.
pub(crate) fn default_pattern_auto_update_notify() -> bool {
    false
}

/// Возвращает дефолтное значение для `pattern_auto_update`.
///
/// По умолчанию автообновление отключено.
pub(crate) fn default_pattern_auto_update_config() -> PatternAutoUpdateConfig {
    PatternAutoUpdateConfig {
        enabled: default_pattern_auto_update_enabled(),
        interval_sec: default_pattern_auto_update_interval_sec(),
        notify_on_update: default_pattern_auto_update_notify(),
    }
}

/// Режим работы Policy Engine.
///
/// Определяет, как Policy Engine вычисляет приоритеты для AppGroup:
///
/// - `rules-only`: Используются только жёсткие правила (guardrails) и семантические правила.
///   ML-ранкер не используется. Это режим по умолчанию и рекомендуется для начального использования.
///
/// - `hybrid`: Комбинация правил и ML-ранкера. Сначала применяются guardrails и семантические правила,
///   затем ML-ранкер используется для ранжирования групп внутри допустимых классов приоритетов.
///   Требует обученной модели CatBoostRanker.
///
/// # Примеры использования в конфигурации
///
/// ```yaml
/// # Режим только правил (по умолчанию)
/// policy_mode: rules-only
///
/// # Гибридный режим с ML-ранкером
/// policy_mode: hybrid
/// ```
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
pub enum PolicyMode {
    /// Только правила, без ML-ранкера.
    /// Используются guardrails и семантические правила для определения приоритетов.
    RulesOnly,
    /// Правила + ML-ранкер для определения приоритетов.
    /// Guardrails и семантические правила имеют приоритет, затем используется ML-ранкер
    /// для ранжирования групп внутри допустимых классов.
    Hybrid,
}

/// Возвращает дефолтное значение для `policy_mode`.
///
/// По умолчанию используется режим `RulesOnly`, который использует только жёсткие правила
/// (guardrails) и семантические правила без ML-ранкера. Это рекомендуется для начального
/// использования, так как не требует обученной модели CatBoostRanker.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_policy_mode")]` для поля `policy_mode`
/// - Для использования ML-ранкера необходимо явно указать `policy_mode: hybrid` в конфигурации
/// - Дефолтное значение применяется автоматически при загрузке конфигурации, если поле `policy_mode` не указано
pub(crate) fn default_policy_mode() -> PolicyMode {
    PolicyMode::RulesOnly
}

/// Возвращает дефолтное значение для `enable_snapshot_logging`.
///
/// По умолчанию логирование снапшотов отключено (`false`). Это позволяет избежать
/// ненужного использования дискового пространства и ресурсов, если логирование не требуется.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_enable_snapshot_logging")]` для поля `enable_snapshot_logging`
/// - Для включения логирования необходимо явно указать `enable_snapshot_logging: true` в конфигурации
/// - Даже если флаг установлен в `true`, логирование не будет работать, если `paths.snapshot_db_path` пуст
/// - Дефолтное значение применяется автоматически при загрузке конфигурации, если поле `enable_snapshot_logging` не указано
pub(crate) fn default_enable_snapshot_logging() -> bool {
    false
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Thresholds {
    pub psi_cpu_some_high: f32,
    pub psi_io_some_high: f32,
    pub user_idle_timeout_sec: u64,
    pub interactive_build_grace_sec: u64,
    pub noisy_neighbour_cpu_share: f32,

    pub crit_interactive_percentile: f32,
    pub interactive_percentile: f32,
    pub normal_percentile: f32,
    pub background_percentile: f32,

    /// Порог для sched_latency_p99_ms (в миллисекундах) для определения bad_responsiveness.
    #[serde(default = "default_sched_latency_p99_threshold")]
    pub sched_latency_p99_threshold_ms: f64,

    /// Порог для ui_loop_p95_ms (в миллисекундах) для определения bad_responsiveness.
    /// По умолчанию 16.67 мс (60 FPS).
    #[serde(default = "default_ui_loop_p95_threshold")]
    pub ui_loop_p95_threshold_ms: f64,
}

/// Возвращает дефолтное значение для `sched_latency_p99_threshold_ms`.
///
/// По умолчанию используется порог 20.0 мс для P99 scheduling latency. Это значение используется
/// для определения `bad_responsiveness` в метриках отзывчивости системы.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_sched_latency_p99_threshold")]`
/// - Порог должен быть положительным и не превышать 1000.0 мс (валидируется в `Thresholds::validate`)
/// - Порог должен быть >= `ui_loop_p95_threshold_ms` (валидируется в `Thresholds::validate`)
/// - Значение 20.0 мс выбрано как разумный порог для P99 latency, превышающий P95 UI loop threshold (16.67 мс)
/// - Дефолтное значение применяется автоматически при загрузке конфигурации, если поле `sched_latency_p99_threshold_ms` не указано
pub(crate) fn default_sched_latency_p99_threshold() -> f64 {
    20.0 // 20 мс по умолчанию
}

/// Возвращает дефолтное значение для `ui_loop_p95_threshold_ms`.
///
/// По умолчанию используется порог 16.67 мс для P95 UI loop latency, что соответствует 60 FPS
/// (1000 мс / 60 кадров ≈ 16.67 мс на кадр). Это значение используется для определения
/// `bad_responsiveness` в метриках отзывчивости системы.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_ui_loop_p95_threshold")]`
/// - Порог должен быть положительным и не превышать 1000.0 мс (валидируется в `Thresholds::validate`)
/// - Порог должен быть <= `sched_latency_p99_threshold_ms` (валидируется в `Thresholds::validate`)
/// - Значение 16.67 мс выбрано как стандартный порог для 60 FPS UI
/// - Дефолтное значение применяется автоматически при загрузке конфигурации, если поле `ui_loop_p95_threshold_ms` не указано
pub(crate) fn default_ui_loop_p95_threshold() -> f64 {
    16.67 // 16.67 мс по умолчанию (60 FPS)
}

/// Интервалы кэширования для оптимизации производительности.
///
/// Определяет, как часто обновляются кэши системных и процессных метрик.
/// Кэширование позволяет снизить нагрузку на систему за счёт повторного использования
/// ранее собранных данных в течение нескольких итераций.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct CacheIntervals {
    /// Интервал кэширования системных метрик (в итерациях).
    ///
    /// Определяет, как часто обновляются системные метрики (CPU, память, нагрузка, PSI).
    /// Значение 1 означает обновление на каждой итерации (кэширование отключено).
    /// Значение N означает обновление каждые N итераций.
    ///
    /// По умолчанию: 3 (обновление каждые 3 итерации).
    ///
    /// # Примечания
    ///
    /// - Системные метрики меняются относительно медленно, поэтому их можно кэшировать
    /// - Кэширование системных метрик может значительно снизить нагрузку на систему
    /// - Значение должно быть >= 1
    #[serde(default = "default_system_metrics_cache_interval")]
    pub system_metrics_cache_interval: u64,
    
    /// Интервал кэширования метрик процессов (в итерациях).
    ///
    /// Определяет, как часто обновляются метрики процессов.
    /// Значение 1 означает обновление на каждой итерации (кэширование отключено).
    /// Значение N означает обновление каждые N итераций.
    ///
    /// По умолчанию: 1 (кэширование отключено, обновление на каждой итерации).
    ///
    /// # Примечания
    ///
    /// - Метрики процессов могут меняться быстро, поэтому кэширование по умолчанию отключено
    /// - Кэширование метрик процессов может быть полезно для снижения нагрузки на систему
    /// - Значение должно быть >= 1
    #[serde(default = "default_process_metrics_cache_interval")]
    pub process_metrics_cache_interval: u64,
}

/// Возвращает дефолтное значение для `system_metrics_cache_interval`.
///
/// По умолчанию используется значение 3, что означает обновление системных метрик
/// каждые 3 итерации. Это позволяет снизить нагрузку на систему за счёт кэширования
/// относительно стабильных системных метрик.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_system_metrics_cache_interval")]`
/// - Значение должно быть >= 1
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_system_metrics_cache_interval() -> u64 {
    3
}

/// Возвращает дефолтное значение для `process_metrics_cache_interval`.
///
/// По умолчанию используется значение 1, что означает отключение кэширования
/// метрик процессов (обновление на каждой итерации). Это связано с тем, что
/// метрики процессов могут меняться быстро и требуют частого обновления.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_process_metrics_cache_interval")]`
/// - Значение должно быть >= 1
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_process_metrics_cache_interval() -> u64 {
    1
}

/// Конфигурация системы уведомлений.
///
/// Определяет параметры отправки уведомлений пользователю о важных событиях
/// в работе демона. Поддерживает различные бэкенды (заглушки, desktop уведомления и т.д.).
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct NotificationConfig {
    /// Включить отправку уведомлений.
    ///
    /// Если `true`, уведомления будут отправляться через выбранный бэкенд.
    /// Если `false`, отправка уведомлений будет отключена, даже если бэкенд настроен.
    ///
    /// По умолчанию: `false` (уведомления отключены).
    ///
    /// # Примечания
    ///
    /// - Это основной переключатель для всей системы уведомлений
    /// - Даже если этот флаг установлен в `true`, уведомления не будут отправляться,
    ///   если бэкенд не поддерживается или не настроен
    /// - Рекомендуется включать уведомления только при необходимости мониторинга
    #[serde(default = "default_notifications_enabled")]
    pub enabled: bool,
    
    /// Тип бэкенда для отправки уведомлений.
    ///
    /// Определяет, какой бэкенд будет использоваться для отправки уведомлений.
    /// Поддерживаются следующие бэкенды:
    ///
    /// - `stub`: Заглушка, которая только логирует уведомления (для тестирования)
    /// - `libnotify`: Desktop уведомления через libnotify (рекомендуется для production)
    ///
    /// По умолчанию: `stub` (заглушка для тестирования).
    ///
    /// # Примечания
    ///
    /// - Бэкенд `libnotify` требует наличия системной библиотеки libnotify
    /// - Если выбранный бэкенд недоступен, будет использоваться заглушка
    /// - Для production использования рекомендуется использовать `libnotify`
    #[serde(default = "default_notification_backend")]
    pub backend: NotificationBackend,
    
    /// Имя приложения для уведомлений.
    ///
    /// Определяет имя приложения, которое будет отображаться в уведомлениях.
    /// Это имя используется в desktop уведомлениях для идентификации источника.
    ///
    /// По умолчанию: `"SmoothTask"`.
    ///
    /// # Примечания
    ///
    /// - Это имя будет отображаться в desktop уведомлениях
    /// - Рекомендуется использовать краткое, но информативное имя
    /// - Имя не должно быть пустым
    #[serde(default = "default_notification_app_name")]
    pub app_name: String,
    
    /// Минимальный уровень важности для отправки уведомлений.
    ///
    /// Определяет минимальный уровень важности уведомлений, которые будут отправляться.
    /// Уведомления с уровнем важности ниже указанного не будут отправляться.
    ///
    /// Поддерживаются следующие уровни:
    ///
    /// - `critical`: Только критические уведомления (самый высокий приоритет)
    /// - `warning`: Предупреждения и критические уведомления
    /// - `info`: Все уведомления (самый низкий приоритет)
    ///
    /// По умолчанию: `warning` (отправляются только предупреждения и критические уведомления).
    ///
    /// # Примечания
    ///
    /// - Это позволяет фильтровать неважные уведомления
    /// - Для production использования рекомендуется использовать `warning` или `critical`
    /// - Уровень `info` может быть полезен для отладки
    #[serde(default = "default_notification_min_level")]
    pub min_level: NotificationLevel,
}

/// Конфигурация ML-модели для ранжирования AppGroup.
///
/// Определяет параметры загрузки и использования ML-модели для ранжирования.
/// Используется только в hybrid режиме Policy Engine.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ModelConfig {
    /// Включить использование ML-модели для ранжирования.
    ///
    /// Если `true`, Policy Engine будет пытаться загрузить и использовать ML-модель
    /// для ранжирования AppGroup в hybrid режиме.
    /// Если `false`, будет использоваться заглушка (StubRanker).
    ///
    /// По умолчанию: `false` (модель отключена).
    ///
    /// # Примечания
    ///
    /// - Это основной переключатель для использования ML-модели
    /// - Даже если этот флаг установлен в `true`, модель не будет использоваться,
    ///   если файл модели не существует или не может быть загружен
    /// - Для использования ML-модели также необходимо установить `policy_mode: hybrid`
    #[serde(default = "default_model_enabled")]
    pub enabled: bool,
    
    /// Путь к ONNX файлу модели для ранжирования.
    ///
    /// Определяет путь к файлу модели в формате ONNX, которая будет использоваться
    /// для ранжирования AppGroup. Модель должна быть обучена с использованием
    /// `smoothtask_trainer.train_ranker` и экспортирована в формат ONNX.
    ///
    /// По умолчанию: `"models/ranker.onnx"` (относительный путь).
    ///
    /// # Примечания
    ///
    /// - Путь может быть абсолютным или относительным
    /// - Относительные пути разрешаются относительно рабочей директории демона
    /// - Если файл не существует или не может быть загружен, будет использоваться заглушка
    /// - Рекомендуется использовать абсолютные пути для production
    #[serde(default = "default_model_path")]
    pub model_path: String,
    
    /// Тип ML-модели для ранжирования.
    ///
    /// Определяет формат модели: CatBoost JSON или ONNX.
    /// Это влияет на то, какой бэкенд будет использоваться для загрузки и выполнения модели.
    ///
    /// По умолчанию: `ModelType::Onnx` (рекомендуется для production).
    ///
    /// # Примечания
    ///
    /// - CatBoost JSON формат удобен для отладки и тестирования
    /// - ONNX формат оптимизирован для production и имеет лучшую производительность
    /// - Тип модели должен соответствовать фактическому формату файла модели
    #[serde(default = "default_model_type")]
    pub model_type: ModelType,
}

/// Тип бэкенда для отправки уведомлений.
///
/// Определяет, какой бэкенд будет использоваться для отправки уведомлений.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
pub enum NotificationBackend {
    /// Заглушка, которая только логирует уведомления (для тестирования).
    Stub,
    /// Desktop уведомления через libnotify.
    Libnotify,
    /// Уведомления через D-Bus (системный D-Bus).
    Dbus,
}

/// Тип ML-модели для ранжирования и классификации.
///
/// Определяет формат ML-модели, которая будет использоваться.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
pub enum ModelType {
    /// CatBoost модель в JSON формате.
    Catboost,
    /// ONNX модель (оптимизированный формат для production).
    Onnx,
}

/// Минимальный уровень важности для отправки уведомлений.
///
/// Определяет минимальный уровень важности уведомлений, которые будут отправляться.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
pub enum NotificationLevel {
    /// Только критические уведомления.
    Critical,
    /// Предупреждения и критические уведомления.
    Warning,
    /// Все уведомления (включая информационные).
    Info,
}

/// Возвращает дефолтное значение для `enabled`.
///
/// По умолчанию уведомления отключены (`false`). Это позволяет избежать
/// ненужных уведомлений во время тестирования и разработки.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_notifications_enabled")]`
/// - Для включения уведомлений необходимо явно указать `enabled: true` в конфигурации
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_notifications_enabled() -> bool {
    false
}

/// Возвращает дефолтное значение для `backend`.
///
/// По умолчанию используется бэкенд `stub` (заглушка). Это позволяет избежать
/// ошибок при отсутствии системных библиотек во время тестирования.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_notification_backend")]`
/// - Для production использования рекомендуется явно указать `backend: libnotify`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_notification_backend() -> NotificationBackend {
    NotificationBackend::Stub
}

/// Возвращает дефолтное значение для `app_name`.
///
/// По умолчанию используется имя `"SmoothTask"`. Это имя будет отображаться
/// в desktop уведомлениях для идентификации источника.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_notification_app_name")]`
/// - Имя не должно быть пустым
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_notification_app_name() -> String {
    "SmoothTask".to_string()
}

/// Возвращает дефолтное значение для `min_level`.
///
/// По умолчанию используется уровень `warning`. Это позволяет отправлять
/// только важные уведомления (предупреждения и критические), избегая
/// информационного шума.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_notification_min_level")]`
/// - Для отладки можно использовать уровень `info`
/// - Для production рекомендуется использовать `warning` или `critical`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_notification_min_level() -> NotificationLevel {
    NotificationLevel::Warning
}

/// Возвращает дефолтное значение для `enabled` ML-модели.
///
/// По умолчанию ML-модель отключена (`false`). Это позволяет избежать
/// ошибок при отсутствии обученной модели и обеспечивает совместимость
/// с существующими конфигурациями.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_model_enabled")]`
/// - Для использования ML-модели необходимо явно включить её в конфигурации
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_model_enabled() -> bool {
    false
}

/// Возвращает дефолтное значение для `model_path` ML-модели.
///
/// По умолчанию используется путь `"models/ranker.onnx"`. Это относительный путь,
/// который будет разрешаться относительно рабочей директории демона.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_model_path")]`
/// - Для production использования рекомендуется использовать абсолютные пути
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_model_path() -> String {
    "models/ranker.onnx".to_string()
}

/// Возвращает дефолтное значение для `model_type`.
///
/// По умолчанию используется `ModelType::Onnx` как рекомендуемый формат
/// для production использования.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_model_type")]`
/// - ONNX формат рекомендуется для production из-за лучшей производительности
/// - CatBoost JSON формат может быть использован для отладки и тестирования
pub(crate) fn default_model_type() -> ModelType {
    ModelType::Onnx
}

/// Возвращает дефолтное значение для `model` конфигурации.
///
/// По умолчанию создаётся конфигурация с отключенной моделью и дефолтным путём.
/// Это обеспечивает совместимость с существующими конфигурациями.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_model_config")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_model_config() -> ModelConfig {
    ModelConfig {
        enabled: default_model_enabled(),
        model_path: default_model_path(),
        model_type: default_model_type(),
    }
}

/// Возвращает дефолтное значение для `cache_intervals`.
///
/// Создаёт структуру CacheIntervals с дефолтными значениями для всех интервалов кэширования.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_cache_intervals")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_cache_intervals() -> CacheIntervals {
    CacheIntervals {
        system_metrics_cache_interval: default_system_metrics_cache_interval(),
        process_metrics_cache_interval: default_process_metrics_cache_interval(),
    }
}

/// Возвращает дефолтное значение для `logging`.
///
/// Создаёт структуру LoggingConfig с дефолтными значениями для всех параметров логирования.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_logging_config")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
pub(crate) fn default_logging_config() -> LoggingConfig {
    LoggingConfig {
        log_max_size_bytes: default_log_max_size_bytes(),
        log_max_rotated_files: default_log_max_rotated_files(),
        log_compression_enabled: default_log_compression_enabled(),
        log_rotation_interval_sec: default_log_rotation_interval_sec(),
    }
}

/// Возвращает дефолтное значение для `notifications`.
///
/// Создаёт структуру NotificationConfig с дефолтными значениями для всех параметров уведомлений.
///
/// # Примечания
///
/// - Это значение используется в `#[serde(default = "default_notification_config")]`
/// - Дефолтное значение применяется автоматически при загрузке конфигурации
/// - По умолчанию уведомления отключены и используется заглушка для тестирования
pub(crate) fn default_notification_config() -> NotificationConfig {
    NotificationConfig {
        enabled: default_notifications_enabled(),
        backend: default_notification_backend(),
        app_name: default_notification_app_name(),
        min_level: default_notification_min_level(),
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Paths {
    pub snapshot_db_path: String,
    pub patterns_dir: String,
    /// Адрес для прослушивания API сервера (например, "127.0.0.1:8080").
    /// Если не указан, API сервер не запускается.
    #[serde(default = "default_api_listen_addr")]
    pub api_listen_addr: Option<String>,
}

/// Возвращает дефолтное значение для `api_listen_addr`.
///
/// По умолчанию API сервер запускается на "127.0.0.1:8080".
/// Если нужно отключить API сервер, можно указать `api_listen_addr: null` в конфиге.
pub(crate) fn default_api_listen_addr() -> Option<String> {
    Some("127.0.0.1:8080".to_string())
}

/// Возвращает дефолтную конфигурацию eBPF.
///
/// По умолчанию eBPF отключен, используются стандартные методы сбора метрик.
pub(crate) fn default_ebpf_config() -> EbpfConfig {
    EbpfConfig::default()
}

impl Config {
    /// Загружает конфигурацию из YAML файла.
    ///
    /// Функция читает файл по указанному пути, парсит YAML и валидирует конфигурацию.
    /// При ошибках чтения, парсинга или валидации возвращается `Result::Err` с описанием проблемы.
    ///
    /// # Примеры использования
    ///
    /// ## Базовое использование
    ///
    /// ```no_run
    /// use smoothtask_core::config::Config;
    ///
    /// let config = Config::load("configs/smoothtask.yml")?;
    /// println!("Polling interval: {} ms", config.polling_interval_ms);
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    ///
    /// ## Обработка ошибок
    ///
    /// ```no_run
    /// use smoothtask_core::config::Config;
    ///
    /// match Config::load("configs/smoothtask.yml") {
    ///     Ok(config) => println!("Config loaded successfully"),
    ///     Err(e) => eprintln!("Failed to load config: {}", e),
    /// }
    /// ```
    ///
    /// ## Использование с переменной окружения
    ///
    /// ```no_run
    /// use smoothtask_core::config::Config;
    /// use std::env;
    ///
    /// let config_path = env::var("SMOOTHTASK_CONFIG")
    ///     .unwrap_or_else(|_| "configs/smoothtask.example.yml".to_string());
    /// let config = Config::load(&config_path)?;
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    ///
    /// # Ошибки
    ///
    /// Функция может вернуть ошибку в следующих случаях:
    ///
    /// - Файл не существует или недоступен для чтения
    /// - Файл содержит некорректный YAML
    /// - Конфигурация не проходит валидацию (некорректные значения полей)
    ///
    /// # Примеры ошибок
    ///
    /// ```no_run
    /// use smoothtask_core::config::Config;
    ///
    /// // Файл не существует
    /// let err = Config::load("/nonexistent/path.yml").unwrap_err();
    /// assert!(err.to_string().contains("failed to read config"));
    ///
    /// // Некорректный YAML
    /// // let err = Config::load("invalid.yaml").unwrap_err();
    /// // assert!(err.to_string().contains("failed to parse YAML"));
    ///
    /// // Валидация не прошла
    /// // let err = Config::load("invalid_config.yml").unwrap_err();
    /// // assert!(err.to_string().contains("must be"));
    /// ```
    pub fn load(path: &str) -> Result<Self> {
        let data = fs::read_to_string(path)
            .with_context(|| format!("failed to read config from {path}"))?;
        let cfg: Config = serde_yaml::from_str(&data)
            .with_context(|| format!("failed to parse YAML config at {path}"))?;
        cfg.validate()?;
        Ok(cfg)
    }

    pub(crate) fn validate(&self) -> Result<()> {
        ensure!(
            self.polling_interval_ms >= 100,
            "polling_interval_ms must be >= 100 ms to prevent excessive system polling (got {})",
            self.polling_interval_ms
        );
        ensure!(
            self.polling_interval_ms <= 60000,
            "polling_interval_ms must be <= 60000 ms (1 minute) to ensure responsive system monitoring (got {})",
            self.polling_interval_ms
        );
        ensure!(
            self.max_candidates > 0,
            "max_candidates must be positive (got {})",
            self.max_candidates
        );
        ensure!(
            self.max_candidates <= 10000,
            "max_candidates must be <= 10000 to prevent excessive memory usage (got {})",
            self.max_candidates
        );

        self.thresholds.validate()?;
        self.paths.validate()?;
        self.cache_intervals.validate()?;
        self.logging.validate()?;

        Ok(())
    }
}

impl Thresholds {
    pub(crate) fn validate(&self) -> Result<()> {
        let percentiles = [
            (
                "crit_interactive_percentile",
                self.crit_interactive_percentile,
            ),
            ("interactive_percentile", self.interactive_percentile),
            ("normal_percentile", self.normal_percentile),
            ("background_percentile", self.background_percentile),
        ];

        for (name, value) in percentiles {
            ensure!(
                (0.0..=1.0).contains(&value),
                "thresholds.{name} must be in the [0, 1] range (got {value})"
            );
        }

        // Валидация упорядоченности percentile порогов
        // Пороги должны быть упорядочены: background <= normal <= interactive <= crit_interactive
        ensure!(
            self.background_percentile <= self.normal_percentile
                && self.normal_percentile <= self.interactive_percentile
                && self.interactive_percentile <= self.crit_interactive_percentile,
            "thresholds: priority percentiles must be non-decreasing from background to critical. \
             Current values: background={}, normal={}, interactive={}, crit_interactive={}. \
             Please ensure: background <= normal <= interactive <= crit_interactive",
            self.background_percentile,
            self.normal_percentile,
            self.interactive_percentile,
            self.crit_interactive_percentile
        );

        ensure!(
            self.psi_cpu_some_high >= 0.0,
            "thresholds.psi_cpu_some_high must be >= 0.0 (got {})",
            self.psi_cpu_some_high
        );
        ensure!(
            self.psi_cpu_some_high <= 1.0,
            "thresholds.psi_cpu_some_high must be <= 1.0 (got {})",
            self.psi_cpu_some_high
        );
        ensure!(
            self.psi_io_some_high >= 0.0,
            "thresholds.psi_io_some_high must be >= 0.0 (got {})",
            self.psi_io_some_high
        );
        ensure!(
            self.psi_io_some_high <= 1.0,
            "thresholds.psi_io_some_high must be <= 1.0 (got {})",
            self.psi_io_some_high
        );
        ensure!(
            self.noisy_neighbour_cpu_share > 0.0,
            "thresholds.noisy_neighbour_cpu_share must be positive (got {})",
            self.noisy_neighbour_cpu_share
        );
        ensure!(
            self.noisy_neighbour_cpu_share <= 1.0,
            "thresholds.noisy_neighbour_cpu_share must be <= 1.0 (got {})",
            self.noisy_neighbour_cpu_share
        );
        ensure!(
            self.user_idle_timeout_sec > 0,
            "thresholds.user_idle_timeout_sec must be positive (got {})",
            self.user_idle_timeout_sec
        );
        ensure!(
            self.user_idle_timeout_sec <= 86400,
            "thresholds.user_idle_timeout_sec must be <= 86400 sec (24 hours) to ensure reasonable user activity tracking. Current value: {} sec. Please use a value between 1 and 86400 seconds.",
            self.user_idle_timeout_sec
        );
        ensure!(
            self.interactive_build_grace_sec > 0,
            "thresholds.interactive_build_grace_sec must be positive (got {})",
            self.interactive_build_grace_sec
        );
        ensure!(
            self.interactive_build_grace_sec <= 3600,
            "thresholds.interactive_build_grace_sec must be <= 3600 sec (1 hour) to ensure reasonable grace period for interactive builds. Current value: {} sec. Please use a value between 1 and 3600 seconds.",
            self.interactive_build_grace_sec
        );
        ensure!(
            self.sched_latency_p99_threshold_ms > 0.0,
            "thresholds.sched_latency_p99_threshold_ms must be positive (got {})",
            self.sched_latency_p99_threshold_ms
        );
        ensure!(
            self.sched_latency_p99_threshold_ms <= 1000.0,
            "thresholds.sched_latency_p99_threshold_ms must be <= 1000.0 ms (1 second) to ensure reasonable latency monitoring (got {})",
            self.sched_latency_p99_threshold_ms
        );
        ensure!(
            self.ui_loop_p95_threshold_ms > 0.0,
            "thresholds.ui_loop_p95_threshold_ms must be positive (got {})",
            self.ui_loop_p95_threshold_ms
        );
        ensure!(
            self.ui_loop_p95_threshold_ms <= 1000.0,
            "thresholds.ui_loop_p95_threshold_ms must be <= 1000.0 ms (1 second) to ensure reasonable UI latency monitoring (got {})",
            self.ui_loop_p95_threshold_ms
        );

        // Логическая валидация: P99 должен быть >= P95, так как P99 - это более высокий перцентиль
        ensure!(
            self.sched_latency_p99_threshold_ms >= self.ui_loop_p95_threshold_ms,
            "thresholds.sched_latency_p99_threshold_ms ({}) must be >= thresholds.ui_loop_p95_threshold_ms ({}) because P99 is a higher percentile than P95",
            self.sched_latency_p99_threshold_ms,
            self.ui_loop_p95_threshold_ms
        );

        Ok(())
    }
}

impl CacheIntervals {
    pub(crate) fn validate(&self) -> Result<()> {
        ensure!(
            self.system_metrics_cache_interval >= 1,
            "cache_intervals.system_metrics_cache_interval must be >= 1 (got {})",
            self.system_metrics_cache_interval
        );
        ensure!(
            self.system_metrics_cache_interval <= 100,
            "cache_intervals.system_metrics_cache_interval must be <= 100 to prevent excessive caching (got {})",
            self.system_metrics_cache_interval
        );
        ensure!(
            self.process_metrics_cache_interval >= 1,
            "cache_intervals.process_metrics_cache_interval must be >= 1 (got {})",
            self.process_metrics_cache_interval
        );
        ensure!(
            self.process_metrics_cache_interval <= 100,
            "cache_intervals.process_metrics_cache_interval must be <= 100 to prevent excessive caching (got {})",
            self.process_metrics_cache_interval
        );

        Ok(())
    }
}

impl LoggingConfig {
    pub(crate) fn validate(&self) -> Result<()> {
        // Валидация log_max_size_bytes
        ensure!(
            self.log_max_size_bytes <= 1_073_741_824,
            "logging.log_max_size_bytes must be <= 1_073_741_824 (1 GiB) to prevent excessive disk usage (got {})",
            self.log_max_size_bytes
        );

        // Валидация log_max_rotated_files
        ensure!(
            self.log_max_rotated_files <= 100,
            "logging.log_max_rotated_files must be <= 100 to prevent excessive disk usage (got {})",
            self.log_max_rotated_files
        );

        // Валидация log_rotation_interval_sec
        ensure!(
            self.log_rotation_interval_sec <= 86400,
            "logging.log_rotation_interval_sec must be <= 86400 (24 hours) to prevent excessive rotation intervals (got {})",
            self.log_rotation_interval_sec
        );

        // Логическая валидация: если ротация по времени включена, интервал должен быть > 0
        if self.log_rotation_interval_sec > 0 {
            ensure!(
                self.log_rotation_interval_sec >= 60,
                "logging.log_rotation_interval_sec must be >= 60 seconds when time-based rotation is enabled (got {})",
                self.log_rotation_interval_sec
            );
        }

        Ok(())
    }
}

impl Paths {
    pub(crate) fn validate(&self) -> Result<()> {
        ensure!(
            !self.snapshot_db_path.trim().is_empty(),
            "snapshot_db_path must not be empty"
        );
        ensure!(
            !self.patterns_dir.trim().is_empty(),
            "patterns_dir must not be empty"
        );

        // Проверяем, что snapshot_db_path имеет расширение .sqlite или .db
        let snapshot_path = Path::new(&self.snapshot_db_path);
        if let Some(ext) = snapshot_path.extension() {
            let ext_str = ext.to_string_lossy().to_lowercase();
            ensure!(
                ext_str == "sqlite" || ext_str == "db",
                "snapshot_db_path must have .sqlite or .db extension (got {:?})",
                ext
            );
        } else {
            anyhow::bail!(
                "snapshot_db_path must have .sqlite or .db extension (got path without extension: {:?})",
                snapshot_path
            );
        }

        // Проверяем, что snapshot_db_path не указывает на директорию (должен быть файл)
        // Если путь уже существует, проверяем, что это не директория
        if snapshot_path.exists() {
            ensure!(
                !snapshot_path.is_dir(),
                "snapshot_db_path must point to a file, not a directory (got directory: {:?})",
                snapshot_path
            );
        }

        let snapshot_parent = Path::new(&self.snapshot_db_path)
            .parent()
            .unwrap_or_else(|| Path::new("."));
        ensure!(
            snapshot_parent.exists(),
            "snapshot_db_path parent directory must exist (got {:?})",
            snapshot_parent,
        );

        // Проверяем, что родительская директория доступна для записи
        // (пробуем создать временный файл для проверки прав доступа)
        #[cfg(unix)]
        {
            use std::fs::File;
            use std::io::Write;
            let test_file = snapshot_parent.join(".smoothtask_write_test");
            if let Ok(mut file) = File::create(&test_file) {
                // Если файл создан, пробуем записать в него
                if file.write_all(b"test").is_ok() {
                    // Удаляем тестовый файл
                    let _ = std::fs::remove_file(&test_file);
                } else {
                    anyhow::bail!(
                        "snapshot_db_path parent directory is not writable (got {:?})",
                        snapshot_parent
                    );
                }
            } else {
                anyhow::bail!(
                    "snapshot_db_path parent directory is not writable (got {:?})",
                    snapshot_parent
                );
            }
        }

        let patterns_dir = Path::new(&self.patterns_dir);
        ensure!(
            patterns_dir.is_dir(),
            "patterns_dir must point to an existing directory (got {:?})",
            patterns_dir,
        );

        // Проверяем, что директория patterns_dir доступна для чтения
        #[cfg(unix)]
        {
            use std::fs::read_dir;
            if read_dir(patterns_dir).is_err() {
                anyhow::bail!("patterns_dir is not readable (got {:?})", patterns_dir);
            }
        }

        // Валидация api_listen_addr, если указан
        if let Some(ref addr) = self.api_listen_addr {
            validate_api_listen_addr(addr)?;
        }

        Ok(())
    }
}

/// Валидирует формат адреса для API сервера (host:port).
///
/// Проверяет, что адрес имеет формат "host:port", где:
/// - host - это IP-адрес или hostname (не пустой)
/// - port - это число в диапазоне 1-65535
///
/// # Аргументы
///
/// * `addr` - строка с адресом в формате "host:port"
///
/// # Возвращает
///
/// `Result<()>` - Ok, если адрес валиден, иначе ошибка с описанием проблемы
fn validate_api_listen_addr(addr: &str) -> Result<()> {
    let parts: Vec<&str> = addr.split(':').collect();
    ensure!(
        parts.len() == 2,
        "api_listen_addr must be in format 'host:port' (got '{}')",
        addr
    );

    let host = parts[0].trim();
    ensure!(
        !host.is_empty(),
        "api_listen_addr host must not be empty (got '{}')",
        addr
    );

    let port_str = parts[1].trim();
    ensure!(
        !port_str.is_empty(),
        "api_listen_addr port must not be empty (got '{}')",
        addr
    );

    let port: u16 = port_str.parse().with_context(|| {
        format!(
            "api_listen_addr port must be a valid number between 1 and 65535 (got '{}' in '{}')",
            port_str, addr
        )
    })?;

    // u16 уже ограничен диапазоном 0-65535, но порт 0 недопустим
    ensure!(
        port > 0,
        "api_listen_addr port must be between 1 and 65535 (got {} in '{}')",
        port,
        addr
    );

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    fn write_temp_config(contents: &str) -> tempfile::NamedTempFile {
        let mut file = tempfile::NamedTempFile::new().expect("tempfile");
        file.write_all(contents.as_bytes())
            .expect("write temp config");
        file
    }

    fn build_config(snapshot_db_path: &str, patterns_dir: &str) -> String {
        format!(
            r#"
polling_interval_ms: 100
max_candidates: 5
dry_run_default: true

paths:
  snapshot_db_path: "{snapshot_db_path}"
  patterns_dir: "{patterns_dir}"

thresholds:
  psi_cpu_some_high: 0.2
  psi_io_some_high: 0.2
  user_idle_timeout_sec: 1
  interactive_build_grace_sec: 1
  noisy_neighbour_cpu_share: 0.5

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.7
  normal_percentile: 0.5
  background_percentile: 0.3
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#
        )
    }

    #[test]
    fn loads_valid_config() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("data").join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");

        assert_eq!(cfg.polling_interval_ms, 500);
        assert_eq!(cfg.max_candidates, 150);
        assert!(!cfg.dry_run_default);
        assert_eq!(cfg.policy_mode, PolicyMode::RulesOnly);
        assert_eq!(
            cfg.paths.snapshot_db_path,
            snapshot_db_path.display().to_string()
        );
        assert_eq!(cfg.paths.patterns_dir, patterns_dir.display().to_string());
        assert!((cfg.thresholds.crit_interactive_percentile - 0.9).abs() < f32::EPSILON);
    }

    #[test]
    fn loads_config_with_hybrid_mode() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false
policy_mode: hybrid

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.to_str().unwrap(),
            patterns_dir.to_str().unwrap()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.policy_mode, PolicyMode::Hybrid);
    }

    #[test]
    fn rejects_invalid_percentile_order() {
        let file = write_temp_config(
            r#"
polling_interval_ms: 100
max_candidates: 1
dry_run_default: true

paths:
  snapshot_db_path: "/tmp/db"
  patterns_dir: "/tmp/patterns"

thresholds:
  psi_cpu_some_high: 0.2
  psi_io_some_high: 0.2
  user_idle_timeout_sec: 1
  interactive_build_grace_sec: 1
  noisy_neighbour_cpu_share: 0.5

  crit_interactive_percentile: 0.4
  interactive_percentile: 0.7
  normal_percentile: 0.2
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
        );

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        let err_str = err.to_string();
        assert!(
            err_str.contains("priority percentiles must be non-decreasing"),
            "unexpected error: {err_str:?}"
        );
        // Проверяем, что сообщение содержит конкретные значения
        assert!(
            err_str.contains("background=")
                && err_str.contains("normal=")
                && err_str.contains("interactive=")
                && err_str.contains("crit_interactive="),
            "error message should contain percentile values: {err_str:?}"
        );
    }

    #[test]
    fn rejects_percentile_order_when_background_greater_than_normal() {
        let file = write_temp_config(
            r#"
polling_interval_ms: 100
max_candidates: 1
dry_run_default: true

paths:
  snapshot_db_path: "/tmp/db"
  patterns_dir: "/tmp/patterns"

thresholds:
  psi_cpu_some_high: 0.2
  psi_io_some_high: 0.2
  user_idle_timeout_sec: 1
  interactive_build_grace_sec: 1
  noisy_neighbour_cpu_share: 0.5

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.2
  background_percentile: 0.3
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
        );

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        let err_str = err.to_string();
        assert!(
            err_str.contains("priority percentiles must be non-decreasing"),
            "unexpected error: {err_str:?}"
        );
        assert!(
            err_str.contains("background=0.3") && err_str.contains("normal=0.2"),
            "error message should contain problematic values: {err_str:?}"
        );
    }

    #[test]
    fn accepts_equal_percentile_values() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 100
max_candidates: 1
dry_run_default: true

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.2
  psi_io_some_high: 0.2
  user_idle_timeout_sec: 1
  interactive_build_grace_sec: 1
  noisy_neighbour_cpu_share: 0.5

  crit_interactive_percentile: 0.5
  interactive_percentile: 0.5
  normal_percentile: 0.5
  background_percentile: 0.5
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен успешно загрузиться, когда все percentile равны (это валидно)
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config should load");
        assert!((cfg.thresholds.background_percentile - 0.5).abs() < f32::EPSILON);
        assert!((cfg.thresholds.normal_percentile - 0.5).abs() < f32::EPSILON);
        assert!((cfg.thresholds.interactive_percentile - 0.5).abs() < f32::EPSILON);
        assert!((cfg.thresholds.crit_interactive_percentile - 0.5).abs() < f32::EPSILON);
    }

    #[test]
    fn errors_include_path_when_file_is_missing() {
        let missing_path = "/non/existent/smoothtask.yml";
        let err = Config::load(missing_path).unwrap_err();
        let message = err.to_string();

        assert!(message.contains(missing_path), "message was: {message}");
        assert!(
            message.contains("failed to read config"),
            "unexpected message: {message}"
        );
    }

    #[test]
    fn rejects_missing_snapshot_parent_directory() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let missing_parent = temp_dir.path().join("no_such").join("snapshots.sqlite");

        let file = write_temp_config(&build_config(
            missing_parent.to_str().unwrap(),
            temp_dir.path().to_str().unwrap(),
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("snapshot_db_path parent directory must exist"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_missing_patterns_directory() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let missing_patterns = temp_dir.path().join("patterns");

        let file = write_temp_config(&build_config(
            temp_dir.path().join("snapshots.sqlite").to_str().unwrap(),
            missing_patterns.to_str().unwrap(),
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("patterns_dir must point to an existing directory"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_polling_interval_too_small() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 50
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("polling_interval_ms must be >= 100"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_polling_interval_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 70000
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("polling_interval_ms must be <= 60000"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_max_candidates_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 20000
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("max_candidates must be <= 10000"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_snapshot_db_path_without_extension() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots"); // без расширения
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("snapshot_db_path must have .sqlite or .db extension"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_snapshot_db_path_with_wrong_extension() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.txt"); // неправильное расширение
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("snapshot_db_path must have .sqlite or .db extension"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_snapshot_db_path_with_db_extension() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.db"); // .db расширение
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен загрузиться без ошибок
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.paths.snapshot_db_path,
            snapshot_db_path.display().to_string()
        );
    }

    #[test]
    fn rejects_sched_latency_p99_threshold_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 2000.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("sched_latency_p99_threshold_ms must be <= 1000.0"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_ui_loop_p95_threshold_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 1000.0
  ui_loop_p95_threshold_ms: 2000.0
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("ui_loop_p95_threshold_ms must be <= 1000.0"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_valid_latency_thresholds() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен загрузиться без ошибок
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.sched_latency_p99_threshold_ms - 20.0).abs() < f64::EPSILON);
        assert!((cfg.thresholds.ui_loop_p95_threshold_ms - 16.67).abs() < f64::EPSILON);
    }

    #[test]
    #[cfg(unix)]
    fn validates_snapshot_db_path_parent_is_writable() {
        // Тест проверяет, что валидация проверяет права на запись в родительскую директорию
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен загрузиться без ошибок (временная директория доступна для записи)
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.paths.snapshot_db_path,
            snapshot_db_path.display().to_string()
        );
    }

    #[test]
    #[cfg(unix)]
    fn rejects_snapshot_db_path_pointing_to_directory() {
        // Тест проверяет, что валидация отклоняет snapshot_db_path, указывающий на директорию
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_dir = temp_dir.path().join("snapshots.sqlite");
        // Создаём директорию с именем, похожим на файл
        std::fs::create_dir_all(&snapshot_db_dir).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_dir.display(),
            patterns_dir.display()
        ));

        // Должен вернуть ошибку, так как snapshot_db_path указывает на директорию
        let result = Config::load(file.path().to_str().unwrap());
        assert!(
            result.is_err(),
            "Config should reject directory as snapshot_db_path"
        );
        let error_msg = result.unwrap_err().to_string();
        assert!(
            error_msg.contains("must point to a file") || error_msg.contains("directory"),
            "Error message should mention that snapshot_db_path must be a file, got: {}",
            error_msg
        );
    }

    #[test]
    #[cfg(unix)]
    fn validates_patterns_dir_is_readable() {
        // Тест проверяет, что валидация проверяет права на чтение директории patterns_dir
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен загрузиться без ошибок (временная директория доступна для чтения)
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.paths.patterns_dir, patterns_dir.display().to_string());
    }

    // Edge cases для polling_interval_ms
    #[test]
    fn rejects_polling_interval_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 0
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("polling_interval_ms must be >= 100"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_polling_interval_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 100
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.polling_interval_ms, 100);
    }

    #[test]
    fn accepts_polling_interval_maximum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 60000
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.polling_interval_ms, 60000);
    }

    // Edge cases для max_candidates
    #[test]
    fn rejects_max_candidates_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 0
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("max_candidates must be positive"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_max_candidates_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 1
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.max_candidates, 1);
    }

    #[test]
    fn accepts_max_candidates_maximum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 10000
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.max_candidates, 10000);
    }

    // Edge cases для percentiles
    #[test]
    fn rejects_percentile_negative() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: -0.1
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("crit_interactive_percentile must be in the [0, 1] range"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_percentile_greater_than_one() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 1.1
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("crit_interactive_percentile must be in the [0, 1] range"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_percentile_boundary_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 1.0
  interactive_percentile: 1.0
  normal_percentile: 1.0
  background_percentile: 1.0
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.crit_interactive_percentile - 1.0).abs() < f32::EPSILON);
    }

    #[test]
    fn rejects_psi_cpu_some_high_negative() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: -0.1
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("psi_cpu_some_high must be >= 0.0"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_psi_io_some_high_negative() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: -0.1
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("psi_io_some_high must be >= 0.0"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_noisy_neighbour_cpu_share_greater_than_one() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 1.1

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("noisy_neighbour_cpu_share must be <= 1.0"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_noisy_neighbour_cpu_share_zero_or_negative() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        // Тест для нуля
        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.0

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("noisy_neighbour_cpu_share must be positive"),
            "unexpected error: {err:?}"
        );

        // Тест для отрицательного значения
        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: -0.1

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("noisy_neighbour_cpu_share must be positive"),
            "unexpected error: {err:?}"
        );
    }

    // Edge cases для latency thresholds
    #[test]
    fn rejects_sched_latency_p99_threshold_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 0.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("sched_latency_p99_threshold_ms must be positive"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_sched_latency_p99_threshold_maximum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 1000.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.sched_latency_p99_threshold_ms - 1000.0).abs() < f64::EPSILON);
    }

    #[test]
    fn rejects_ui_loop_p95_threshold_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 10.0
  ui_loop_p95_threshold_ms: 0.0
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("ui_loop_p95_threshold_ms must be positive"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_ui_loop_p95_threshold_maximum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 1000.0
  ui_loop_p95_threshold_ms: 1000.0
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.ui_loop_p95_threshold_ms - 1000.0).abs() < f64::EPSILON);
    }

    // Edge cases для timeouts
    #[test]
    fn rejects_user_idle_timeout_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 0
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("user_idle_timeout_sec must be positive"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_interactive_build_grace_sec_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 0
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("interactive_build_grace_sec must be positive"),
            "unexpected error: {err:?}"
        );
    }

    // Edge cases для путей с пробелами
    #[test]
    fn rejects_snapshot_db_path_with_only_spaces() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "   "
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("snapshot_db_path must not be empty"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_patterns_dir_with_only_spaces() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "   "

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("patterns_dir must not be empty"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_user_idle_timeout_sec_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 100000
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("user_idle_timeout_sec must be <= 86400"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_interactive_build_grace_sec_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10000
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("interactive_build_grace_sec must be <= 3600"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_valid_timeout_values() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 3600
  interactive_build_grace_sec: 1800
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен успешно загрузиться с валидными значениями
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config should load");
        assert_eq!(cfg.thresholds.user_idle_timeout_sec, 3600);
        assert_eq!(cfg.thresholds.interactive_build_grace_sec, 1800);
    }

    // Валидация логического соотношения между latency thresholds
    #[test]
    fn rejects_sched_latency_p99_threshold_less_than_ui_loop_p95_threshold() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 10.0
  ui_loop_p95_threshold_ms: 20.0
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        let err_msg = err.to_string();
        assert!(
            err_msg.contains("sched_latency_p99_threshold_ms")
                && err_msg.contains("must be >=")
                && err_msg.contains("ui_loop_p95_threshold_ms"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_sched_latency_p99_threshold_equal_to_ui_loop_p95_threshold() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 16.67
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен успешно загрузиться, когда пороги равны
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config should load");
        assert!((cfg.thresholds.sched_latency_p99_threshold_ms - 16.67).abs() < f64::EPSILON);
        assert!((cfg.thresholds.ui_loop_p95_threshold_ms - 16.67).abs() < f64::EPSILON);
    }

    #[test]
    fn accepts_sched_latency_p99_threshold_greater_than_ui_loop_p95_threshold() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Должен успешно загрузиться, когда P99 > P95
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config should load");
        assert!((cfg.thresholds.sched_latency_p99_threshold_ms - 20.0).abs() < f64::EPSILON);
        assert!((cfg.thresholds.ui_loop_p95_threshold_ms - 16.67).abs() < f64::EPSILON);
    }

    #[test]
    fn policy_mode_defaults_to_rules_only() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        // policy_mode не указан, должен быть дефолтным (RulesOnly)
        assert_eq!(cfg.policy_mode, PolicyMode::RulesOnly);
    }

    #[test]
    fn policy_mode_accepts_rules_only() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false
policy_mode: rules-only

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.policy_mode, PolicyMode::RulesOnly);
    }

    #[test]
    fn policy_mode_accepts_hybrid() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false
policy_mode: hybrid

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.policy_mode, PolicyMode::Hybrid);
    }

    #[test]
    fn accepts_percentile_boundary_one() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 1.0
  psi_io_some_high: 1.0
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 1.0

  crit_interactive_percentile: 1.0
  interactive_percentile: 1.0
  normal_percentile: 1.0
  background_percentile: 1.0
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.psi_cpu_some_high - 1.0).abs() < f32::EPSILON);
        assert!((cfg.thresholds.psi_io_some_high - 1.0).abs() < f32::EPSILON);
        assert!((cfg.thresholds.noisy_neighbour_cpu_share - 1.0).abs() < f32::EPSILON);
    }

    #[test]
    fn rejects_psi_cpu_some_high_greater_than_one() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 1.1
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("psi_cpu_some_high must be <= 1.0"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_psi_io_some_high_greater_than_one() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 1.1
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string().contains("psi_io_some_high must be <= 1.0"),
            "unexpected error: {err:?}"
        );
    }

    // Тесты для проверки консистентности дефолтных значений
    #[test]
    fn default_policy_mode_returns_rules_only() {
        assert_eq!(default_policy_mode(), PolicyMode::RulesOnly);
    }

    #[test]
    fn default_sched_latency_p99_threshold_returns_expected_value() {
        let default = default_sched_latency_p99_threshold();
        assert!(
            (default - 20.0).abs() < f64::EPSILON,
            "Expected 20.0, got {}",
            default
        );
    }

    #[test]
    fn default_ui_loop_p95_threshold_returns_expected_value() {
        let default = default_ui_loop_p95_threshold();
        assert!(
            (default - 16.67).abs() < f64::EPSILON,
            "Expected 16.67, got {}",
            default
        );
    }

    #[test]
    fn default_sched_latency_p99_threshold_is_valid() {
        // Проверяем, что дефолтное значение проходит валидацию
        let default = default_sched_latency_p99_threshold();
        assert!(
            default > 0.0,
            "Default sched_latency_p99_threshold_ms must be positive, got {}",
            default
        );
        assert!(
            default <= 1000.0,
            "Default sched_latency_p99_threshold_ms must be <= 1000.0, got {}",
            default
        );
    }

    #[test]
    fn default_ui_loop_p95_threshold_is_valid() {
        // Проверяем, что дефолтное значение проходит валидацию
        let default = default_ui_loop_p95_threshold();
        assert!(
            default > 0.0,
            "Default ui_loop_p95_threshold_ms must be positive, got {}",
            default
        );
        assert!(
            default <= 1000.0,
            "Default ui_loop_p95_threshold_ms must be <= 1000.0, got {}",
            default
        );
    }

    #[test]
    fn default_latency_thresholds_are_consistent() {
        // Проверяем, что дефолтные значения latency thresholds консистентны
        // (sched_latency_p99_threshold_ms >= ui_loop_p95_threshold_ms)
        let sched_p99 = default_sched_latency_p99_threshold();
        let ui_p95 = default_ui_loop_p95_threshold();
        assert!(
            sched_p99 >= ui_p95,
            "Default sched_latency_p99_threshold_ms ({}) must be >= ui_loop_p95_threshold_ms ({})",
            sched_p99,
            ui_p95
        );
    }

    #[test]
    fn config_without_latency_thresholds_uses_defaults() {
        // Проверяем, что при отсутствии latency thresholds в конфиге используются дефолты
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!(
            (cfg.thresholds.sched_latency_p99_threshold_ms - default_sched_latency_p99_threshold())
                .abs()
                < f64::EPSILON,
            "sched_latency_p99_threshold_ms should use default value"
        );
        assert!(
            (cfg.thresholds.ui_loop_p95_threshold_ms - default_ui_loop_p95_threshold()).abs()
                < f64::EPSILON,
            "ui_loop_p95_threshold_ms should use default value"
        );
    }

    #[test]
    fn config_without_policy_mode_uses_default() {
        // Проверяем, что при отсутствии policy_mode в конфиге используется дефолт
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.policy_mode,
            default_policy_mode(),
            "policy_mode should use default value"
        );
    }

    #[test]
    fn default_values_pass_validation() {
        // Проверяем, что дефолтные значения проходят валидацию при создании Thresholds
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        // Создаём конфиг с дефолтными значениями для latency thresholds
        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        // Конфиг должен успешно загрузиться с дефолтными значениями
        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        // Проверяем, что валидация прошла успешно (нет ошибок)
        assert!(
            cfg.thresholds.sched_latency_p99_threshold_ms > 0.0,
            "sched_latency_p99_threshold_ms should be positive"
        );
        assert!(
            cfg.thresholds.ui_loop_p95_threshold_ms > 0.0,
            "ui_loop_p95_threshold_ms should be positive"
        );
        assert!(
            cfg.thresholds.sched_latency_p99_threshold_ms
                >= cfg.thresholds.ui_loop_p95_threshold_ms,
            "sched_latency_p99_threshold_ms should be >= ui_loop_p95_threshold_ms"
        );
    }

    // Тесты для enable_snapshot_logging
    #[test]
    fn enable_snapshot_logging_defaults_to_false() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        // enable_snapshot_logging не указан, должен быть дефолтным (false)
        assert!(!cfg.enable_snapshot_logging);
    }

    #[test]
    fn enable_snapshot_logging_accepts_true() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false
enable_snapshot_logging: true

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!(cfg.enable_snapshot_logging);
    }

    #[test]
    fn enable_snapshot_logging_accepts_false() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false
enable_snapshot_logging: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!(!cfg.enable_snapshot_logging);
    }

    #[test]
    fn default_enable_snapshot_logging_returns_false() {
        assert!(!default_enable_snapshot_logging());
    }

    #[test]
    fn config_without_enable_snapshot_logging_uses_default() {
        // Проверяем, что при отсутствии enable_snapshot_logging в конфиге используется дефолт
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.enable_snapshot_logging,
            default_enable_snapshot_logging(),
            "enable_snapshot_logging should use default value"
        );
    }

    #[test]
    fn accepts_psi_cpu_some_high_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.0
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.psi_cpu_some_high - 0.0).abs() < f32::EPSILON);
    }

    #[test]
    fn accepts_psi_io_some_high_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.0
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!((cfg.thresholds.psi_io_some_high - 0.0).abs() < f32::EPSILON);
    }

    #[test]
    fn accepts_noisy_neighbour_cpu_share_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.0001

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!(cfg.thresholds.noisy_neighbour_cpu_share > 0.0);
    }

    #[test]
    fn rejects_noisy_neighbour_cpu_share_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.0

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("noisy_neighbour_cpu_share must be positive"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_user_idle_timeout_sec_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 1
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.thresholds.user_idle_timeout_sec, 1);
    }

    #[test]
    fn accepts_user_idle_timeout_sec_maximum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 86400
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.thresholds.user_idle_timeout_sec, 86400);
    }

    #[test]
    fn accepts_interactive_build_grace_sec_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 1
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.thresholds.interactive_build_grace_sec, 1);
    }

    #[test]
    fn accepts_interactive_build_grace_sec_maximum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 3600
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.thresholds.interactive_build_grace_sec, 3600);
    }

    #[test]
    fn accepts_sched_latency_p99_threshold_minimum() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 0.0001
  ui_loop_p95_threshold_ms: 0.0001
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert!(cfg.thresholds.sched_latency_p99_threshold_ms > 0.0);
        assert!(cfg.thresholds.ui_loop_p95_threshold_ms > 0.0);
    }

    // Тесты для валидации api_listen_addr
    #[test]
    fn accepts_valid_api_listen_addr() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1:8080"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.paths.api_listen_addr,
            Some("127.0.0.1:8080".to_string())
        );
    }

    #[test]
    fn accepts_valid_api_listen_addr_with_different_port() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "0.0.0.0:3000"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.paths.api_listen_addr, Some("0.0.0.0:3000".to_string()));
    }

    #[test]
    fn accepts_valid_api_listen_addr_with_hostname() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "localhost:8080"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.paths.api_listen_addr,
            Some("localhost:8080".to_string())
        );
    }

    #[test]
    fn rejects_api_listen_addr_without_port() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("api_listen_addr must be in format 'host:port'"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_api_listen_addr_without_host() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: ":8080"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("api_listen_addr host must not be empty"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_api_listen_addr_with_port_zero() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1:0"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("api_listen_addr port must be between 1 and 65535"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn rejects_api_listen_addr_with_port_too_large() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1:65536"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        let err_str = err.to_string();
        // Порт 65536 не помещается в u16, поэтому ошибка будет о парсинге числа
        // Проверяем, что ошибка связана с api_listen_addr и портом
        assert!(
            err_str.contains("api_listen_addr") && err_str.contains("port"),
            "unexpected error: {err_str:?}"
        );
    }

    #[test]
    fn rejects_api_listen_addr_with_invalid_port() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1:abc"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let err = Config::load(file.path().to_str().unwrap()).unwrap_err();
        assert!(
            err.to_string()
                .contains("api_listen_addr port must be a valid number"),
            "unexpected error: {err:?}"
        );
    }

    #[test]
    fn accepts_api_listen_addr_with_maximum_port() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1:65535"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(
            cfg.paths.api_listen_addr,
            Some("127.0.0.1:65535".to_string())
        );
    }

    #[test]
    fn accepts_api_listen_addr_with_minimum_port() {
        let temp_dir = tempfile::tempdir().expect("tempdir");
        let snapshot_db_path = temp_dir.path().join("snapshots.sqlite");
        std::fs::create_dir_all(snapshot_db_path.parent().unwrap()).expect("snapshot dir");
        let patterns_dir = temp_dir.path().join("patterns");
        std::fs::create_dir_all(&patterns_dir).expect("patterns dir");

        let file = write_temp_config(&format!(
            r#"
polling_interval_ms: 500
max_candidates: 150
dry_run_default: false

paths:
  snapshot_db_path: "{}"
  patterns_dir: "{}"
  api_listen_addr: "127.0.0.1:1"

thresholds:
  psi_cpu_some_high: 0.6
  psi_io_some_high: 0.4
  user_idle_timeout_sec: 120
  interactive_build_grace_sec: 10
  noisy_neighbour_cpu_share: 0.7

  crit_interactive_percentile: 0.9
  interactive_percentile: 0.6
  normal_percentile: 0.3
  background_percentile: 0.1
  sched_latency_p99_threshold_ms: 20.0
  ui_loop_p95_threshold_ms: 16.67
        "#,
            snapshot_db_path.display(),
            patterns_dir.display()
        ));

        let cfg = Config::load(file.path().to_str().unwrap()).expect("config loads");
        assert_eq!(cfg.paths.api_listen_addr, Some("127.0.0.1:1".to_string()));
    }
}

/// Реализация Default для MLClassifierConfig.
impl Default for MLClassifierConfig {
    fn default() -> Self {
        Self {
            enabled: default_ml_classifier_enabled(),
            model_path: default_ml_classifier_model_path(),
            confidence_threshold: default_ml_classifier_confidence_threshold(),
            model_type: default_ml_classifier_model_type(),
        }
    }
}

/// Реализация Default для PatternAutoUpdateConfig.
impl Default for PatternAutoUpdateConfig {
    fn default() -> Self {
        Self {
            enabled: default_pattern_auto_update_enabled(),
            interval_sec: default_pattern_auto_update_interval_sec(),
            notify_on_update: default_pattern_auto_update_notify(),
        }
    }
}

/// Возвращает дефолтное значение для `psi_cpu_some_high`.
pub(crate) fn default_psi_cpu_some_high() -> f32 {
    0.6
}

/// Возвращает дефолтное значение для `psi_io_some_high`.
pub(crate) fn default_psi_io_some_high() -> f32 {
    0.4
}

/// Возвращает дефолтное значение для `user_idle_timeout_sec`.
pub(crate) fn default_user_idle_timeout_sec() -> u64 {
    120
}

/// Возвращает дефолтное значение для `interactive_build_grace_sec`.
pub(crate) fn default_interactive_build_grace_sec() -> u64 {
    10
}

/// Возвращает дефолтное значение для `noisy_neighbour_cpu_share`.
pub(crate) fn default_noisy_neighbour_cpu_share() -> f32 {
    0.7
}

/// Возвращает дефолтное значение для `crit_interactive_percentile`.
pub(crate) fn default_crit_interactive_percentile() -> f32 {
    0.9
}

/// Возвращает дефолтное значение для `interactive_percentile`.
pub(crate) fn default_interactive_percentile() -> f32 {
    0.6
}

/// Возвращает дефолтное значение для `normal_percentile`.
pub(crate) fn default_normal_percentile() -> f32 {
    0.3
}

/// Возвращает дефолтное значение для `background_percentile`.
pub(crate) fn default_background_percentile() -> f32 {
    0.1
}

/// Возвращает дефолтное значение для `sched_latency_p99_threshold_ms`.
pub(crate) fn default_sched_latency_p99_threshold_ms() -> f64 {
    20.0
}

/// Возвращает дефолтное значение для `ui_loop_p95_threshold_ms`.
pub(crate) fn default_ui_loop_p95_threshold_ms() -> f64 {
    16.67
}

/// Возвращает дефолтное значение для `snapshot_db_path`.
pub(crate) fn default_snapshot_db_path() -> String {
    "snapshots.db".to_string()
}

/// Возвращает дефолтное значение для `patterns_dir`.
pub(crate) fn default_patterns_dir() -> String {
    "patterns".to_string()
}

/// Возвращает дефолтное значение для `polling_interval_ms`.
pub(crate) fn default_polling_interval_ms() -> u64 {
    1000
}

/// Возвращает дефолтное значение для `max_candidates`.
pub(crate) fn default_max_candidates() -> usize {
    150
}

/// Возвращает дефолтное значение для `dry_run_default`.
pub(crate) fn default_dry_run_default() -> bool {
    false
}

/// Реализация Default для Thresholds.
impl Default for Thresholds {
    fn default() -> Self {
        Self {
            psi_cpu_some_high: default_psi_cpu_some_high(),
            psi_io_some_high: default_psi_io_some_high(),
            user_idle_timeout_sec: default_user_idle_timeout_sec(),
            interactive_build_grace_sec: default_interactive_build_grace_sec(),
            noisy_neighbour_cpu_share: default_noisy_neighbour_cpu_share(),
            crit_interactive_percentile: default_crit_interactive_percentile(),
            interactive_percentile: default_interactive_percentile(),
            normal_percentile: default_normal_percentile(),
            background_percentile: default_background_percentile(),
            sched_latency_p99_threshold_ms: default_sched_latency_p99_threshold_ms(),
            ui_loop_p95_threshold_ms: default_ui_loop_p95_threshold_ms(),
        }
    }
}

/// Реализация Default для Paths.
impl Default for Paths {
    fn default() -> Self {
        Self {
            snapshot_db_path: default_snapshot_db_path(),
            patterns_dir: default_patterns_dir(),
            api_listen_addr: default_api_listen_addr(),
        }
    }
}

/// Реализация Default для LoggingConfig.
impl Default for LoggingConfig {
    fn default() -> Self {
        Self {
            log_max_size_bytes: default_log_max_size_bytes(),
            log_max_rotated_files: default_log_max_rotated_files(),
            log_compression_enabled: default_log_compression_enabled(),
            log_rotation_interval_sec: default_log_rotation_interval_sec(),
        }
    }
}

/// Реализация Default для CacheIntervals.
impl Default for CacheIntervals {
    fn default() -> Self {
        Self {
            system_metrics_cache_interval: default_system_metrics_cache_interval(),
            process_metrics_cache_interval: default_process_metrics_cache_interval(),
        }
    }
}

/// Реализация Default для NotificationConfig.
impl Default for NotificationConfig {
    fn default() -> Self {
        Self {
            enabled: default_notifications_enabled(),
            backend: default_notification_backend(),
            app_name: default_notification_app_name(),
            min_level: default_notification_min_level(),
        }
    }
}

/// Реализация Default для ModelConfig.
impl Default for ModelConfig {
    fn default() -> Self {
        Self {
            enabled: default_model_enabled(),
            model_path: default_model_path(),
            model_type: default_model_type(),
        }
    }
}

/// Реализация Default для Config.
impl Default for Config {
    fn default() -> Self {
        Self {
            polling_interval_ms: default_polling_interval_ms(),
            max_candidates: default_max_candidates(),
            dry_run_default: default_dry_run_default(),
            policy_mode: default_policy_mode(),
            enable_snapshot_logging: default_enable_snapshot_logging(),
            thresholds: Thresholds::default(),
            paths: Paths::default(),
            logging: LoggingConfig::default(),
            cache_intervals: CacheIntervals::default(),
            notifications: NotificationConfig::default(),
            model: ModelConfig::default(),
            ml_classifier: MLClassifierConfig::default(),
            pattern_auto_update: PatternAutoUpdateConfig::default(),
            ebpf: EbpfConfig::default(),
        }
    }
}
